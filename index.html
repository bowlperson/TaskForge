<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <title>TaskForge â€” Gamified Productivity</title>
  <meta name="description" content="Turn your day into an RPG. Create quests, earn XP, and level up Main Stats + Skills." />
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#0ea5e9" />
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 256 256'%3E%3Crect width='256' height='256' rx='56' fill='%230ea5e9'/%3E%3Ctext x='50%25' y='55%25' text-anchor='middle' font-size='48' fill='white' font-family='monospace'%3ETF%3C/text%3E%3C/svg%3E" />
  <style>
    * { scrollbar-width: thin; }
    body.theme-default { background-color: #0f172a; color: #f1f5f9; }
    body.theme-dark { background-color: #000; color: #e5e7eb; }
    body.theme-emerald { background-color: #064e3b; color: #d1fae5; }
    body.theme-rose { background-color: #881337; color: #ffe4e6; }
    body.theme-amber { background-color: #78350f; color: #fffbeb; }
    #dungeon-log {
      max-height: 9.5rem;
      min-height: 9.5rem;
      overflow-y: auto;
      font-family: "Courier New", Courier, monospace;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }
    #dungeon-log .chat-block {
      background-color: rgba(15, 23, 42, 0.65);
      border-radius: 0.5rem;
      padding: 0.35rem 0.65rem;
    }
    #dungeon-log .chat-line {
      display: block;
      line-height: 1.2;
      word-break: break-word;
    }
    .q-card.completed-today {
      opacity: 0.55;
      filter: saturate(0.45);
      transition: opacity 0.2s ease, filter 0.2s ease;
    }
    .q-card.completed-today:hover {
      opacity: 0.7;
      filter: saturate(0.6);
    }
    .inbox-section-label {
      display: block;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      font-size: 0.65rem;
      color: rgba(148, 163, 184, 0.75);
      margin-bottom: 0.3rem;
    }
    .inbox-card-pinned {
      border: 1px solid rgba(14, 165, 233, 0.45);
    }

    .hold-btn {
      --btn-bg: #16a34a;
      --btn-bg-dark: #0e7a39;
      --btn-text: #eafff1;
      --btn-glow: rgba(34, 197, 94, 0.4);
      --track: rgba(255, 255, 255, 0.06);
      --fill1: rgba(80, 200, 255, 0.9);
      --fill2: rgba(0, 150, 200, 0.35);
      --spark1: #5cf4ff;
      --spark2: #3bd1c8;
      position: relative;
      display: inline-grid;
      place-items: center;
      width: 100%;
      min-height: 44px;
      border-radius: 0.75rem;
      border: none;
      background: linear-gradient(180deg, var(--btn-bg), var(--btn-bg-dark));
      color: var(--btn-text);
      font-weight: 600;
      font-size: 0.95rem;
      cursor: pointer;
      box-shadow: 0 6px 18px -6px var(--btn-glow);
      outline: none;
      overflow: hidden;
      user-select: none;
      transition: transform 0.15s ease;
    }
    .hold-btn[data-variant="attack"] {
      --btn-bg: #dc2626;
      --btn-bg-dark: #991b1b;
      --btn-text: #fee2e2;
      --btn-glow: rgba(248, 113, 113, 0.45);
      --fill1: rgba(248, 113, 113, 0.9);
      --fill2: rgba(239, 68, 68, 0.4);
      --spark1: #f87171;
      --spark2: #fb7185;
    }
    .hold-btn:focus-visible {
      box-shadow: 0 0 0 3px rgba(56, 189, 248, 0.45), 0 6px 20px -6px rgba(56, 189, 248, 0.35);
    }
    .hold-btn:active {
      transform: scale(0.98);
    }
    .hold-btn .track {
      position: absolute;
      inset: 0;
      background: var(--track);
      border-radius: inherit;
      opacity: 0;
      transition: opacity 0.15s ease;
    }
    .hold-btn.holding .track {
      opacity: 1;
    }
    .hold-btn .fill {
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      width: 0%;
      background: linear-gradient(90deg, var(--fill1), var(--fill2));
      box-shadow: inset -10px 0 30px -20px rgba(255, 255, 255, 0.9);
      opacity: 0;
      transition: opacity 0.2s ease;
    }
    .hold-btn.holding .fill {
      opacity: 1;
    }
    .hold-btn .label-text {
      position: relative;
      z-index: 1;
      pointer-events: none;
    }
    .hold-btn .pop-ring {
      position: absolute;
      inset: 0;
      border-radius: inherit;
      pointer-events: none;
      opacity: 0;
    }
    .hold-btn .pop-ring.show {
      animation: hold-ring 0.5s ease-out both;
    }
    @keyframes hold-ring {
      0% {
        box-shadow: 0 0 0 0 rgba(100, 220, 255, 0.7);
        opacity: 1;
      }
      100% {
        box-shadow: 0 0 0 18px rgba(100, 220, 255, 0);
        opacity: 0;
      }
    }
    @keyframes hold-pop {
      0% {
        transform: scale(1);
      }
      55% {
        transform: scale(1.06);
      }
      100% {
        transform: scale(1);
      }
    }

    #hold-fx {
      position: fixed;
      inset: 0;
      pointer-events: none;
      overflow: visible;
      z-index: 50;
    }
    #hold-fx .spark {
      position: absolute;
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: radial-gradient(circle at 30% 30%, var(--spark-color-1), var(--spark-color-2));
      filter: drop-shadow(0 0 6px var(--spark-color-1));
      transform: translate(var(--x0), var(--y0)) scale(0.9);
      animation: sparkMove 0.7s ease-out forwards, sparkFade 0.7s ease-out forwards;
    }
    @keyframes sparkMove {
      to {
        transform: translate(var(--x1), var(--y1)) scale(0.6);
      }
    }
    @keyframes sparkFade {
      0% {
        opacity: 1;
      }
      70% {
        opacity: 0.9;
      }
      100% {
        opacity: 0;
      }
    }

    #hold-rewards {
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: 60;
    }
    #hold-rewards .drop {
      position: fixed;
      left: var(--cx, 50%);
      top: var(--cy, 50%);
      transform: translate(-50%, -50%);
      font-weight: 600;
      font-size: 1.1rem;
      letter-spacing: 0.3px;
      text-shadow: 0 0 10px rgba(255, 255, 255, 0.18), 0 0 18px rgba(255, 255, 255, 0.1);
      filter: drop-shadow(0 0 6px rgba(255, 255, 255, 0.1));
      opacity: 0;
      will-change: transform, opacity;
      animation: hold-reward 2.4s ease-out forwards;
      white-space: nowrap;
    }
    @keyframes hold-reward {
      0% {
        opacity: 0;
        transform: translate(calc(-50% + var(--x, 0px)), calc(-50% + var(--y, 0px)));
      }
      10% {
        opacity: 1;
      }
      100% {
        opacity: 0;
        transform: translate(calc(-50% + var(--x2, 0px)), calc(-50% + var(--y2, 120px)));
      }
    }
    #hold-rewards .drop.xp {
      color: #86efac;
      text-shadow: 0 0 14px rgba(34, 197, 94, 0.6), 0 0 28px rgba(34, 197, 94, 0.35);
    }
    #hold-rewards .drop.gold {
      color: #facc15;
      text-shadow: 0 0 14px rgba(250, 204, 21, 0.55), 0 0 28px rgba(250, 204, 21, 0.3);
    }
    #hold-rewards .drop.stat,
    #hold-rewards .drop.skill,
    #hold-rewards .drop.damage {
      color: #f8fafc;
      text-shadow: 0 0 12px rgba(226, 232, 240, 0.55), 0 0 24px rgba(226, 232, 240, 0.28);
    }
    #hold-rewards .drop.dmg {
      color: #f87171;
      text-shadow: 0 0 14px rgba(248, 113, 113, 0.55), 0 0 28px rgba(248, 113, 113, 0.28);
    }
    #hold-rewards .drop.dice {
      color: #4ade80;
      text-shadow: 0 0 14px rgba(74, 222, 128, 0.55), 0 0 28px rgba(74, 222, 128, 0.28);
    }
    #hold-rewards .drop.miss {
      color: #facc15;
      text-shadow: 0 0 14px rgba(250, 204, 21, 0.55), 0 0 28px rgba(250, 204, 21, 0.28);
    }
  </style>
</head>
<body class="bg-slate-950 text-slate-100 min-h-screen theme-default">
  <div id="hold-fx"></div>
  <div id="hold-rewards" class="rewards-layer"></div>
  <div class="h-8 md:h-10"></div>
  <div class="max-w-6xl mx-auto p-4 md:p-8">
    <header class="flex flex-col gap-2 md:flex-row md:items-center md:justify-between">
      <h1 class="text-3xl font-bold">TaskForge <span class="text-sky-400">Beta</span></h1>
      <div class="flex gap-2 items-center">
        <div id="streak-display" class="text-sm"></div>
        <div class="relative">
          <button id="btn-open-inbox" class="px-3 py-2 rounded-lg bg-slate-800 hover:bg-slate-700">Inbox</button>
          <span id="inbox-badge" class="absolute -top-2 -right-2 text-xs font-semibold bg-rose-600 text-white px-1.5 py-0.5 rounded-full hidden"></span>
        </div>
        <button id="btn-open-settings" class="px-3 py-2 rounded-lg bg-slate-800 hover:bg-slate-700">Settings</button>
      </div>
    </header>

    <section class="mt-6 grid md:grid-cols-3 gap-6">
      <!-- Player Card -->
      <div class="md:col-span-1">
        <div class="rounded-2xl bg-slate-900/60 ring-1 ring-white/10 p-4">
          <h2 class="text-xl font-semibold mb-3 flex items-center justify-between">
              <span><span id="player-name-display"></span> <span id="edit-name" class="text-xs cursor-pointer text-sky-400 ml-2">edit</span></span>
            </h2>
            <div class="space-y-2">
              <div class="flex flex-col items-center mt-2">
                <img id="player-img" src="Sprites/Commoner.png" alt="Player" class="w-24 h-24 object-contain" />
                <div id="player-title" class="mt-2 font-semibold">Commoner</div>
              </div>
              <div class="grid grid-cols-2 gap-2 mt-2">
                <div class="rounded bg-slate-800 p-3">
                  <div class="text-3xl font-bold" id="level">1</div>
                  <div class="text-xs opacity-70">Level</div>
                </div>
                <div class="rounded bg-slate-800 p-3">
                  <div class="text-3xl font-bold" id="xp">0</div>
                  <div class="text-xs opacity-70">XP</div>
                </div>
                <div class="rounded bg-slate-800 p-3">
                  <div class="text-3xl font-bold" id="prestige">0</div>
                  <div class="text-xs opacity-70">Prestige</div>
                </div>
                <div class="rounded bg-slate-800 p-3">
                  <div class="text-3xl font-bold" id="gold">0</div>
                  <div class="text-xs opacity-70">Gold</div>
                </div>
              </div>
              <div class="mt-3">
                <div class="flex items-center justify-between text-xs opacity-80">
                  <span>XP Progress</span>
                  <span><span id="xp-current">0</span>/<span id="next-xp">50</span> XP</span>
                </div>
                <div class="w-full h-2 bg-slate-800 rounded-full overflow-hidden mt-1">
                  <div id="xp-progress" class="h-2 bg-sky-500 transition-all duration-300 ease-out" style="width: 0%"></div>
                </div>
                <div class="text-xs opacity-70 mt-1">Next level in <span id="xp-remaining">50</span> XP</div>
              </div>

            <div class="mt-4 grid grid-cols-2 gap-2">
              <button id="btn-open-quests" class="w-full text-left font-semibold hover:text-sky-300">Quests</button>
              <button id="btn-open-status" class="w-full text-left font-semibold hover:text-sky-300">Status</button>
              <button id="btn-open-stats" class="w-full text-left font-semibold hover:text-sky-300">Main Stats</button>
              <button id="btn-open-skills" class="w-full text-left font-semibold hover:text-sky-300">Skills</button>
              <button id="btn-open-tags" class="w-full text-left font-semibold hover:text-sky-300">Tags</button>
              <button id="btn-open-shop" class="w-full text-left font-semibold hover:text-sky-300">Shop</button>
              <button id="btn-open-inventory" class="w-full text-left font-semibold hover:text-sky-300">Inventory</button>
              <button id="btn-open-notes" class="w-full text-left font-semibold hover:text-sky-300">Journal</button>
              <button id="btn-open-log" class="w-full text-left font-semibold hover:text-sky-300 col-span-2">Audit Log</button>
              <button id="btn-open-dungeon" class="w-full text-left font-semibold hover:text-sky-300 col-span-2">Codex</button>
            </div>
            </div>
        </div>
      </div>

      <!-- Right Pane Views -->
      <div class="md:col-span-2">
        <div class="rounded-2xl bg-slate-900/60 ring-1 ring-white/10 p-4 min-h-[420px]" id="view-container">
          <!-- Quests View -->
          <div id="view-quests">
            <h2 class="text-xl font-semibold mb-3">Quests</h2>
            <button id="btn-show-form" class="px-4 py-2 mb-3 rounded bg-sky-700 hover:bg-sky-600">Create New Quest</button>
            <div id="quest-filter-container" class="flex flex-col text-xs mb-3"></div>
            <form id="quest-form" class="hidden grid grid-cols-1 sm:grid-cols-2 md:grid-cols-7 gap-2 items-end">
              <div class="md:col-span-2 sm:col-span-2">
                <label class="text-sm opacity-80">Title</label>
                <input id="q-title" class="w-full px-3 py-2 rounded bg-slate-800" placeholder="Gym: Push Day" />
              </div>
              <div>
                <label class="text-sm opacity-80">Difficulty</label>
                <select id="q-diff" class="w-full px-3 py-2 rounded bg-slate-800">
                  <option value="100">Trivial (100 XP)</option>
                  <option value="250">Routine (250 XP)</option>
                  <option value="1000" selected>Standard (1,000 XP)</option>
                  <option value="1500">Challenging (1,500 XP)</option>
                  <option value="2750">Formative (2,750 XP)</option>
                </select>
              </div>
              <div>
              <label class="text-sm opacity-80">Time Completion</label>
              <select id="q-time" class="w-full px-3 py-2 rounded bg-slate-800">
                  <option value="1" selected>&gt;30mins (1x)</option>
                  <option value="1.25">1hr+ (1.25x)</option>
                  <option value="1.6">2hr+ (1.6x)</option>
                  <option value="3.5">4hr+ (3.5x)</option>
                  <option value="7">8hr+ (7x)</option>
                  <option value="9">Day(s)+ (9x)</option>
                </select>
              </div>
              <div class="md:col-span-2">
                <label class="text-sm opacity-80">Skills</label>
                <div id="q-skills" class="space-y-1"></div>
                <label class="flex items-center gap-2 text-xs mt-1"><input type="checkbox" id="q-adjust" class="rounded"> Adjust skill values</label>
                <button type="button" id="btn-add-skill-row" class="mt-1 px-2 py-1 text-xs rounded bg-slate-800 hover:bg-slate-700">Add Skill</button>
              </div>
              <div class="md:col-span-2">
                <label class="text-sm opacity-80">Main Stats</label>
                <div id="q-stats" class="space-y-1"></div>
                <label class="flex items-center gap-2 text-xs mt-1"><input type="checkbox" id="q-stat-adjust" class="rounded"> Adjust stat values</label>
                <button type="button" id="btn-add-stat-row" class="mt-1 px-2 py-1 text-xs rounded bg-slate-800 hover:bg-slate-700">Add Stat</button>
              </div>
              <div class="md:col-span-2">
                <label class="text-sm opacity-80">Tags</label>
                <div id="q-tag-options" class="w-full rounded bg-slate-800 p-2 max-h-36 overflow-y-auto space-y-1 text-xs"></div>
              </div>
              <div>
                <label class="text-sm opacity-80">Note Color</label>
                <input id="q-note-color" type="color" value="#0ea5e9" class="w-full h-10 p-0 rounded bg-slate-800 border-0" />
              </div>
              <div>
                <label class="text-sm opacity-80">Due Date</label>
                <input id="q-due" type="date" class="w-full px-3 py-2 rounded bg-slate-800" />
              </div>
              <div class="sm:col-span-2 md:col-span-7 flex flex-wrap items-center gap-4">
                <label class="flex items-center gap-2 text-sm"><input type="checkbox" id="q-repeat" class="rounded"> Repeatable</label>
                <select id="q-repeat-frequency" class="px-3 py-2 rounded bg-slate-800 text-xs hidden">
                  <option value="daily">Daily</option>
                  <option value="bi-daily">Bi-Daily</option>
                  <option value="weekly">Weekly</option>
                  <option value="bi-weekly">Bi-Weekly</option>
                  <option value="monthly">Monthly</option>
                </select>
                <span id="q-anti" class="text-sm cursor-pointer text-rose-400">Anti Quest</span>
              </div>
              <div class="md:col-span-7 sm:col-span-2">
                <label class="text-sm opacity-80">Notes</label>
                <textarea id="q-notes" class="w-full px-3 py-2 rounded bg-slate-800" rows="2"></textarea>
              </div>
              <div class="md:col-span-7 sm:col-span-2 flex gap-2 flex-wrap">
                <button id="btn-submit-quest" class="px-4 py-2 rounded bg-emerald-700 hover:bg-emerald-600">Add Quest</button>
                <button type="button" id="btn-quest-ungrey" class="px-4 py-2 rounded bg-slate-700 hover:bg-slate-600 hidden" title="Clears today's completion timestamp so the quest is active again.">Ungrey Quest</button>
                <button type="button" id="btn-clear-done" class="px-4 py-2 rounded bg-slate-800 hover:bg-slate-700">Clear Completed</button>
              </div>
            </form>
            <div id="quest-list" class="mt-4 grid gap-3"></div>
          </div>

          <div id="view-stats" class="hidden"><h2 class="text-xl font-semibold mb-3">Main Stats</h2><div id="stats-list"></div></div>
          <div id="view-status" class="hidden">
            <h2 class="text-xl font-semibold mb-3">Status Effects</h2>
            <p class="text-xs opacity-70 mb-3">Active buffs and debuffs gathered from dungeon expeditions and consumables.</p>
            <div id="status-list" class="space-y-2"></div>
          </div>
          <div id="view-skills" class="hidden">
            <h2 class="text-xl font-semibold mb-3 flex items-center justify-between">Skills <button id="btn-add-skill" class="text-xs px-2 py-1 rounded bg-emerald-700 hover:bg-emerald-600">Add Skill</button></h2>
            <div id="skills-list"></div>
          </div>
          <div id="view-tags" class="hidden">
            <h2 class="text-xl font-semibold mb-3">Tags</h2>
            <div class="flex gap-2 mb-4 items-center">
              <input id="tag-name" class="flex-1 px-3 py-2 rounded bg-slate-800" placeholder="Tag name" />
              <input id="tag-color" type="color" value="#0ea5e9" class="w-14 h-10 p-0 border-0 rounded bg-slate-800" />
              <input id="tag-priority" type="number" min="0" class="w-16 px-3 py-2 rounded bg-slate-800" placeholder="0" />
              <button id="btn-add-tag" class="px-3 py-2 rounded bg-emerald-700 hover:bg-emerald-600">+</button>
            </div>
            <div id="tags-list"></div>
          </div>
          <div id="view-shop" class="hidden">
            <h2 class="text-xl font-semibold mb-3">Shop</h2>
            <button id="btn-show-shop-form" class="px-4 py-2 mb-3 rounded bg-sky-700 hover:bg-sky-600">Create Item</button>
            <form id="shop-form" class="hidden grid grid-cols-1 sm:grid-cols-2 gap-2 mb-4">
              <div class="sm:col-span-2">
                <label class="text-sm opacity-80">Title</label>
                <input id="shop-title" class="w-full px-3 py-2 rounded bg-slate-800" />
              </div>
              <div class="sm:col-span-2">
                <label class="text-sm opacity-80">Description</label>
                <textarea id="shop-desc" class="w-full px-3 py-2 rounded bg-slate-800" rows="2"></textarea>
              </div>
              <div>
                <label class="text-sm opacity-80">Cost</label>
                <input id="shop-cost" type="number" class="w-full px-3 py-2 rounded bg-slate-800" />
              </div>
              <div>
                <label class="text-sm opacity-80">Image</label>
                <input id="shop-img" type="file" accept="image/png" class="w-full text-sm" />
              </div>
              <div class="sm:col-span-2 flex items-center gap-2">
                <label class="flex items-center gap-2 text-sm"><input type="checkbox" id="shop-rebuy" class="rounded"> Rebuy</label>
              </div>
              <div class="sm:col-span-2 flex gap-2">
                <button id="btn-add-shop" class="px-4 py-2 rounded bg-emerald-700 hover:bg-emerald-600">Add Item</button>
              </div>
            </form>
            <div id="shop-list" class="grid gap-3"></div>
          </div>
          <div id="view-inventory" class="hidden">
            <h2 class="text-xl font-semibold mb-3">Inventory</h2>
            <div id="inventory-list" class="grid grid-cols-3 gap-2"></div>
          </div>
          <div id="view-inbox" class="hidden">
            <h2 class="text-xl font-semibold mb-3">Inbox</h2>
            <div id="inbox-list" class="grid gap-3 text-sm"></div>
          </div>
          <div id="view-notes" class="hidden">
            <h2 class="text-xl font-semibold mb-3 flex items-center justify-between">Journal <button id="btn-show-note-form" class="text-xs px-2 py-1 rounded bg-sky-700 hover:bg-sky-600">New Entry</button></h2>
            <form id="note-form" class="hidden grid grid-cols-1 sm:grid-cols-2 gap-2 mb-4">
              <div>
                <label class="text-sm opacity-80">Title</label>
                <input id="note-title" class="w-full px-3 py-2 rounded bg-slate-800" placeholder="Reminder" />
              </div>
              <div>
                <label class="text-sm opacity-80">Color</label>
                <input id="note-color" type="color" value="#0ea5e9" class="w-full h-10 p-0 rounded bg-slate-800 border-0" />
              </div>
              <div class="sm:col-span-2">
                <label class="text-sm opacity-80">Tags</label>
                <div id="note-tag-options" class="w-full rounded bg-slate-800 p-2 max-h-36 overflow-y-auto space-y-1 text-xs"></div>
              </div>
              <div class="sm:col-span-2">
                <label class="text-sm opacity-80">Details</label>
                <textarea id="note-body" rows="3" class="w-full px-3 py-2 rounded bg-slate-800"></textarea>
              </div>
              <div class="sm:col-span-2 flex gap-2">
                <button id="btn-save-note" class="px-4 py-2 rounded bg-emerald-700 hover:bg-emerald-600">Save Entry</button>
                <button type="button" id="btn-cancel-note" class="px-4 py-2 rounded bg-slate-800 hover:bg-slate-700">Cancel</button>
              </div>
            </form>
            <div id="note-filter-container" class="flex flex-col text-xs mb-3"></div>
            <div id="note-list" class="grid gap-3"></div>
          </div>
          <div id="view-log" class="hidden"><h2 class="text-xl font-semibold mb-3">Audit Log</h2><div id="log-list"></div></div>
          <div id="view-dungeon" class="hidden">
            <h2 class="text-xl font-semibold mb-3">Codex</h2>
            <div id="dungeon-stats" class="text-sm mb-3">
              Highest Codex Run: <span id="dungeon-highest">0</span> Monster(s) Defeated<br/>
              Current Run: <span id="dungeon-current">0</span> Monster(s) Defeated
            </div>
            <div id="dungeon-monster" class="mb-4 text-center"></div>
            <div class="mb-4">
              <h3 class="font-semibold mb-1 text-sm">Codex Entries</h3>
              <div id="dungeon-log" class="text-xs space-y-1"></div>
            </div>
            <div id="dungeon-quests" class="mb-4"></div>
            <div id="dungeon-actions" class="text-center"></div>
          </div>
          <div id="view-settings" class="hidden">
            <h2 class="text-xl font-semibold mb-3">Settings</h2>
            <div class="mb-4">
              <button id="btn-audio-toggle" class="w-full flex justify-between items-center font-semibold">
                <span>Audio</span><span id="audio-toggle-symbol">-</span>
              </button>
              <div id="audio-section" class="mt-2">
                <label class="block mb-2 text-sm">Level Up Sound</label>
                <select id="level-sound" class="w-full px-3 py-2 rounded bg-slate-800">
                  <option value="0">Fallout</option>
                  <option value="1">Skyrim</option>
                </select>
                <label class="block mt-4 mb-2 text-sm">Volume</label>
                <input id="audio-volume" type="range" min="0" max="1" step="0.01" class="w-full" />
              </div>
            </div>
            <div class="mb-4">
              <h3 class="font-semibold mb-2">Notifications</h3>
              <div class="flex items-center justify-between gap-2">
                <span class="text-sm">Inbox Push Notifications</span>
                <button id="btn-toggle-notifications" class="px-3 py-2 rounded bg-slate-800 hover:bg-slate-700 text-sm"></button>
              </div>
              <div id="notification-status" class="text-xs opacity-70 mt-2"></div>
            </div>
            <div class="mb-4">
              <h3 class="font-semibold mb-2">Daily Routine</h3>
              <label class="block text-sm opacity-80">Daily Reset Time</label>
              <input id="daily-reset-time" type="time" value="04:00" class="mt-1 w-full px-3 py-2 rounded bg-slate-800" />
              <p class="text-xs opacity-70 mt-2">Controls when reminders and the Daily Mail refresh.</p>
            </div>
            <div class="mb-4">
              <h3 class="font-semibold mb-2">Save Data</h3>
              <div class="flex gap-2">
                <button id="btn-export" class="flex-1 px-3 py-2 rounded bg-slate-800 hover:bg-slate-700">Export</button>
                <label class="flex-1 px-3 py-2 rounded bg-slate-800 hover:bg-slate-700 cursor-pointer text-center">Import
                  <input id="file-import" type="file" accept="application/json" class="hidden" />
                </label>
              </div>
            </div>
            <div class="mb-4">
              <h3 class="font-semibold mb-2">Developer</h3>
              <label class="block mb-2 text-sm">Color Theme</label>
              <select id="dev-theme" class="w-full px-3 py-2 rounded bg-slate-800 mb-4">
                <option value="default">Default</option>
                <option value="dark">Dark Mode</option>
                <option value="emerald">Emerald</option>
                <option value="rose">Rose</option>
                <option value="amber">Amber</option>
              </select>
              <h4 class="font-semibold mb-2">Titles</h4>
              <div id="dev-titles" class="space-y-2"></div>
              <h4 class="font-semibold mb-2 mt-4">Assets</h4>
              <div id="dev-monsters" class="space-y-2 mb-2"></div>
              <button id="btn-save-assets" class="px-2 py-1 rounded bg-emerald-700 hover:bg-emerald-600 text-sm mb-3">Save Custom Assets</button>
              <label class="block mb-1 text-sm">Default Shop Item Image</label>
              <input id="dev-shop-img" type="file" accept="image/png" class="w-full text-sm mb-4"/>
              <h4 class="font-semibold mb-2">Item Audio</h4>
              <div id="dev-item-audio" class="space-y-2 mb-2"></div>
              <button id="dev-add-item-audio" class="px-2 py-1 rounded bg-slate-800 hover:bg-slate-700 text-sm mb-4">Add Item Audio</button>
            </div>
            <div class="mb-4">
              <h3 class="font-semibold mb-2">Quest Filters</h3>
              <p class="text-xs opacity-70 mb-2">Pick the tags that should appear when the Custom filter is active for Quests and Journal.</p>
              <div id="custom-filter-settings" class="rounded bg-slate-800 p-3 space-y-1 text-xs"></div>
            </div>
            <div class="mb-4">
              <h3 class="font-semibold mb-2">Danger Zone</h3>
              <button id="btn-reset" class="w-full px-3 py-2 rounded bg-rose-700 hover:bg-rose-600">Hard Reset</button>
            </div>
          </div>
        </div>
      </div>
    </section>
  </div>
  <div id="streak-timer" class="fixed top-2 left-2 text-xs"></div>

  <template id="tpl-quest">
    <div class="rounded-xl bg-slate-800 p-3 ring-1 ring-white/10 q-card">
      <h3 class="q-title font-semibold"></h3>
      <div class="mt-1 text-xs flex items-center gap-1">
        <span class="px-2 py-0.5 rounded bg-sky-700/50"><span class="q-xp"></span> XP</span>
        <span class="px-2 py-0.5 rounded bg-fuchsia-700/40 q-tag-stat"></span>
        <span class="px-2 py-0.5 rounded bg-amber-700/40 q-tag-skill hidden"></span>
      </div>
      <div class="mt-1 flex flex-wrap gap-1 q-tag-pills"></div>
      <div class="q-due text-xs opacity-70 mt-1"></div>
      <div class="q-last-completed text-xs opacity-60 mt-1 hidden"></div>
      <p class="q-notes text-sm opacity-85 mt-2"></p>
      <div class="mt-3 flex gap-2">
        <button type="button" class="q-complete hold-btn flex-1" data-variant="quest" aria-label="Hold to complete quest">
          <span class="track" aria-hidden="true"></span>
          <span class="fill" aria-hidden="true"></span>
          <span class="label-text">Completed</span>
          <span class="pop-ring" aria-hidden="true"></span>
        </button>
        <button class="q-edit px-3 py-2 rounded bg-sky-700 hover:bg-sky-600 text-sm">Edit</button>
        <button class="q-delete px-3 py-2 rounded bg-rose-700 hover:bg-rose-600 text-sm">Delete</button>
      </div>
    </div>
  </template>

  <template id="tpl-log">
    <div class="rounded-xl bg-slate-800 p-3 ring-1 ring-white/10">
      <div class="flex items-start justify-between gap-3">
        <div class="flex-1">
          <h3 class="l-title font-semibold"></h3>
          <div class="text-xs opacity-70 mt-1"><span class="l-xp"></span> XP <span class="l-stat"></span> <span class="l-skill"></span> <span class="l-due"></span> <span class="l-time text-sky-400"></span></div>
          <p class="l-notes text-sm opacity-85 mt-1"></p>
        </div>
        <button class="l-undo text-xs px-2 py-1 rounded bg-rose-700 hover:bg-rose-600">Undo</button>
      </div>
    </div>
  </template>

  <div id="modal" class="fixed inset-0 bg-black/60 hidden flex items-center justify-center">
    <div id="modal-box" class="bg-slate-900 p-4 rounded-lg max-w-sm w-full"></div>
  </div>

<script>
const DEFAULT_SKILLS = [
  { name: "Fitness", priority: 3, desc: "strength, endurance, and physical training that builds your body over time." },
  { name: "Study", priority: 1, desc: "focused learning sessions, absorbing knowledge, and structured practice." },
  { name: "Strategy", priority: 1, desc: "tactical games, Chess, Puzzles, competitive strategy." },
  { name: "Writing", priority: 3, desc: "creative expression, journaling, or refining your ability to communicate through words." },
  { name: "Productivity", priority: 5, desc: "Completing need to do Quest, organizing your time, and completing things on time." },
  { name: "Mindfulness", priority: 2, desc: "meditation, and practicing awareness, enjoy and take break." },
  { name: "Cooking", priority: 3, desc: "preparing meals and learning recipes." },
  { name: "Reading", priority: 4, desc: "consuming literature and books." },
  { name: "Vitality", priority: 2, desc: "energy, health, and wellbeing." }
];
const DEFAULT_SAVE = {
  player: {
    name: "Bowl",
    level: 1,
    xp: 0,
    prestige: 0,
    gold: 0,
    mainstats: {
      Strength: 0,
      Dexterity: 0,
      Constitution: 0,
      Intelligence: 0,
      Wisdom: 0,
      Charisma: 0
    },
    skills: Object.fromEntries(DEFAULT_SKILLS.map(s => [s.name, 0])),
    statuses: []
  },
  quests: [],
  log: [],
  tags: [],
  skills: DEFAULT_SKILLS,
  shop: [],
  inventory: [],
  streak: { count: 0, last: 0 },
  notes: [],
  inbox: [],
  settings: { levelSound: 0, audioCollapsed: false, volume: 1, theme: "default", titles: {}, monsterImages: {}, defaultShopImg: "", itemAudio: {}, customFilterTags: [], notificationsEnabled: false, dailyResetTime: "04:00" },
  dungeon: { current: null, chat: [], currentRun: 0, highestRun: 0, usedLogs: [], recentMonsters: [], activeMonsterKey: null }
};
const el = id => document.getElementById(id);
const holdFxLayer = el("hold-fx");
const holdRewardsLayer = el("hold-rewards");
const HOLD_BUTTON_DURATION = 1100;
const CODEX_KEY = "codex";
const state =
  JSON.parse(localStorage.getItem("taskforge_save") || "null") ||
  structuredClone(DEFAULT_SAVE);
if (!state.tags) state.tags = [];
state.tags.forEach(t => { if (t.priority === undefined) t.priority = 0; });
if (!state.skills) state.skills = DEFAULT_SKILLS.slice();
if (!state.player.skills) state.player.skills = {};
Object.keys(state.player.skills).forEach(k => {
  if (!state.skills.some(s => s.name === k)) state.skills.push({ name: k, priority: 3, desc: "" });
});
state.skills.forEach(s => { if (state.player.skills[s.name] === undefined) state.player.skills[s.name] = 0; });
if (state.player.prestige === undefined) state.player.prestige = 0;
if (state.player.gold === undefined) state.player.gold = 0;
if (!state.shop) state.shop = [];
if (!state.inventory) state.inventory = [];
if (!state.notes) state.notes = [];
if (!Array.isArray(state.inbox)) state.inbox = [];
state.inbox = state.inbox
  .filter(msg => msg && typeof msg === "object")
  .map(msg => ({
    ...msg,
    id: msg.id || crypto.randomUUID(),
    title: msg.title || "Message",
    body: msg.body || "",
    timestamp: msg.timestamp || Date.now(),
    read: msg.read !== undefined ? !!msg.read : true,
    source: msg.source || "system",
    pinned: !!msg.pinned,
    dayKey: msg.dayKey || null
  }));
if (!state.streak) state.streak = { count: 0, last: 0 };
if (!state.settings) state.settings = { levelSound: 0, audioCollapsed: false, volume: 1, theme: "default", titles: {}, monsterImages: {}, defaultShopImg: "", itemAudio: {}, customFilterTags: [], notificationsEnabled: false, dailyResetTime: "04:00" };
if (state.settings.volume === undefined) state.settings.volume = 1;
if (!state.settings.theme) state.settings.theme = "default";
if (!state.settings.titles) state.settings.titles = {};
if (!state.settings.monsterImages) state.settings.monsterImages = {};
if (state.settings.defaultShopImg === undefined) state.settings.defaultShopImg = "";
if (!state.settings.itemAudio) state.settings.itemAudio = {};
if (!state.settings.customFilterTags) state.settings.customFilterTags = [];
if (state.settings.notificationsEnabled === undefined) state.settings.notificationsEnabled = false;
if (!state.settings.dailyResetTime) state.settings.dailyResetTime = "04:00";
if (!state.player.statuses) state.player.statuses = [];
if (!state.dungeon) state.dungeon = { current: null, chat: [], currentRun: 0, highestRun: 0, usedLogs: [], recentMonsters: [], activeMonsterKey: null };
if (!Array.isArray(state.dungeon.chat)) state.dungeon.chat = [];
if (!Array.isArray(state.dungeon.recentMonsters)) state.dungeon.recentMonsters = [];
if (state.dungeon.activeMonsterKey === undefined) state.dungeon.activeMonsterKey = null;
if (state.dungeon.current && !state.dungeon.activeMonsterKey) {
  state.dungeon.activeMonsterKey = crypto.randomUUID();
}
const fallbackMonsterKey =
  state.dungeon.activeMonsterKey ||
  state.dungeon.recentMonsters.slice(-1)[0] ||
  (state.dungeon.chat.length ? "legacy" : null);
state.dungeon.chat = state.dungeon.chat.map(entry => {
  if (!entry || typeof entry !== "object") {
    return {
      id: crypto.randomUUID(),
      title: String(entry || ""),
      lines: [],
      monsterKey: fallbackMonsterKey,
      createdAt: Date.now()
    };
  }
  return {
    id: entry.id || crypto.randomUUID(),
    title: entry.title || "",
    lines: Array.isArray(entry.lines) ? entry.lines : [],
    monsterKey: entry.monsterKey || fallbackMonsterKey,
    createdAt: entry.createdAt || Date.now()
  };
});
if (fallbackMonsterKey && !state.dungeon.recentMonsters.includes(fallbackMonsterKey)) {
  state.dungeon.recentMonsters.push(fallbackMonsterKey);
}
state.quests.forEach(q => {
  if (q.stat && !q.stats) {
    q.stats = q.stat ? [q.stat] : [];
    delete q.stat;
  }
  if (q.skill && !q.skills) {
    q.skills = q.skill ? [{ name: q.skill, mult: 1 }] : [];
    delete q.skill;
  }
  if (q.stats && q.stats.length && typeof q.stats[0] === "string") {
    q.stats = q.stats.map(s => ({ name: s, mult: 1 }));
  }
  if (!Array.isArray(q.tags)) {
    if (q.tag !== undefined) {
      q.tags = q.tag ? [q.tag] : [];
      delete q.tag;
    } else {
      q.tags = [];
    }
  }
  if (!q.noteColor) q.noteColor = "#0ea5e9";
  if (q.due) {
    if (/^\d{4}-\d{2}-\d{2}$/.test(q.due)) {
      q.due = q.due;
    } else {
      const parsed = new Date(q.due);
      if (!Number.isNaN(parsed.getTime())) {
        q.due = `${parsed.getFullYear()}-${pad(parsed.getMonth() + 1)}-${pad(parsed.getDate())}`;
      } else {
        q.due = "";
      }
    }
  } else {
    q.due = "";
  }
  if (q.repeat && !q.repeatFrequency) q.repeatFrequency = "daily";
  if (!q.repeat) q.repeatFrequency = null;
  if (q.lastCompletedAt !== undefined) {
    q.lastCompletedAt = q.lastCompletedAt ? +q.lastCompletedAt : null;
  } else {
    q.lastCompletedAt = null;
  }
  if (!q.reminderTracker || typeof q.reminderTracker !== "object") {
    q.reminderTracker = {};
  }
});
state.log.forEach(l => {
  if (l.stat && !l.stats) {
    l.stats = l.stat ? [{ name: l.stat, points: l.statPoints }] : [];
  }
  if (l.skill && !l.skills) {
    l.skills = l.skill ? [{ name: l.skill, points: l.skillPoints }] : [];
  }
  if (!Array.isArray(l.tags)) {
    if (l.tag !== undefined) {
      l.tags = l.tag ? [l.tag] : [];
      delete l.tag;
    } else {
      l.tags = [];
    }
  }
  if (l.noteColor === undefined) l.noteColor = null;
  if (l.repeatFrequency === undefined) l.repeatFrequency = null;
  if (l.previousDue === undefined) l.previousDue = l.due || "";
  if (l.previousLastCompletedAt === undefined) l.previousLastCompletedAt = null;
  if (!l.previousReminderTracker || typeof l.previousReminderTracker !== "object") l.previousReminderTracker = null;
  if (l.lastCompletedAt !== undefined) {
    l.lastCompletedAt = l.lastCompletedAt ? +l.lastCompletedAt : null;
  } else {
    l.lastCompletedAt = null;
  }
});
if (state.streak.last && Date.now() - state.streak.last > 30 * 60 * 60 * 1000) {
  state.streak.count = 0;
  state.streak.last = 0;
}
let statsChart = null;
let editingId = null;
let editingClearCompletion = false;
let editingShopId = null;
let antiQuest = false;
let editingNoteId = null;
const QUEST_FILTER_ALL = "__all";
const QUEST_FILTER_CUSTOM = "__custom";
const DAILY_MAIL_ID = "daily-mail";
const MS_PER_DAY = 24 * 60 * 60 * 1000;
let questFilterSelection = QUEST_FILTER_ALL;
let noteFilterSelection = QUEST_FILTER_ALL;
const goldSound = new Audio("Sound Effects/goldcoins.mp3");
const levelSounds = [
  new Audio("Sound Effects/lvlupfallout.mp3"),
  new Audio("Sound Effects/lvlupskyrim.mp3")
];
const attackSound = new Audio("Sound Effects/Attack.mp3");
let currentLvlSound = null;
goldSound.volume = state.settings.volume;
levelSounds.forEach(s => (s.volume = state.settings.volume));
attackSound.volume = state.settings.volume;
let dungeonTimer = null;
const consumeSound = new Audio("Sound Effects/consume.mp3");
const drinkSound = new Audio("Sound Effects/drink.mp3");
consumeSound.volume = state.settings.volume;
drinkSound.volume = state.settings.volume;

function playItemSound(item) {
  const cfg = state.settings.itemAudio[item.title];
  let audio;
  if (cfg) {
    if (cfg.type === "custom" && cfg.src) {
      audio = new Audio(cfg.src);
      audio.volume = state.settings.volume;
    } else if (cfg.type === "drink") {
      audio = drinkSound;
    } else {
      audio = consumeSound;
    }
  } else {
    audio = /potion/i.test(item.title) ? drinkSound : consumeSound;
  }
  audio.play();
}

function showModal(content) {
  const box = el("modal-box");
  box.innerHTML = "";
  box.appendChild(content);
  el("modal").classList.remove("hidden");
}

function closeModal() {
  el("modal").classList.add("hidden");
}

function hexToRgba(hex, alpha = 0.2) {
  if (!hex) return `rgba(14,165,233,${alpha})`;
  let value = hex.replace("#", "");
  if (value.length === 3) value = value.split("").map(ch => ch + ch).join("");
  const num = parseInt(value, 16);
  if (Number.isNaN(num)) return `rgba(14,165,233,${alpha})`;
  const r = (num >> 16) & 255;
  const g = (num >> 8) & 255;
  const b = num & 255;
  return `rgba(${r}, ${g}, ${b}, ${alpha})`;
}

function setUngreyButtonState({ visible = false, active = false } = {}) {
  const btn = el("btn-quest-ungrey");
  if (!btn) return;
  btn.classList.toggle("hidden", !visible);
  btn.classList.toggle("bg-emerald-700", active);
  btn.classList.toggle("hover:bg-emerald-600", active);
  btn.classList.toggle("bg-slate-700", !active);
  btn.classList.toggle("hover:bg-slate-600", !active);
  btn.textContent = active ? "Will Ungrey on Save (click to undo)" : "Ungrey Quest";
  btn.dataset.active = active ? "true" : "false";
  btn.setAttribute("aria-pressed", active ? "true" : "false");
}

function addStatus(status) {
  const existing = state.player.statuses.findIndex(s => s.id === status.id);
  if (existing !== -1) {
    state.player.statuses[existing] = { ...state.player.statuses[existing], ...status };
  } else {
    state.player.statuses.push(status);
  }
  save();
  renderStatusPage();
}

function removeStatus(id) {
  const idx = state.player.statuses.findIndex(s => s.id === id);
  if (idx !== -1) {
    state.player.statuses.splice(idx, 1);
    save();
    renderStatusPage();
  }
}

function decrementStatusUse(id) {
  const status = state.player.statuses.find(s => s.id === id);
  if (!status || status.uses === undefined) return;
  status.uses = Math.max(0, status.uses - 1);
  if (status.uses === 0) {
    removeStatus(id);
  } else {
    save();
    renderStatusPage();
  }
}

function renderStatusPage() {
  const list = el("status-list");
  if (!list) return;
  list.innerHTML = "";
  if (!state.player.statuses.length) {
    list.innerHTML = '<div class="text-sm opacity-70">No active statuses.</div>';
    return;
  }
  state.player.statuses.forEach(status => {
    const wrap = document.createElement("div");
    wrap.className = `${status.type === "debuff" ? "bg-rose-900/40" : "bg-emerald-900/30"} rounded-lg p-3 ring-1 ring-white/10`;
    const header = document.createElement("div");
    header.className = "flex justify-between items-start";
    const title = document.createElement("div");
    title.innerHTML = `<div class="font-semibold">${status.name}</div><div class="text-xs opacity-80 mt-1">${status.desc || ""}</div>`;
    header.appendChild(title);
    if (status.uses !== undefined) {
      const uses = document.createElement("span");
      uses.className = "text-xs opacity-70";
      uses.textContent = `Uses: ${status.uses}`;
      header.appendChild(uses);
    } else if (status.expiresAt) {
      const exp = document.createElement("span");
      exp.className = "text-xs opacity-70";
      exp.textContent = new Date(status.expiresAt).toLocaleString();
      header.appendChild(exp);
    }
    wrap.appendChild(header);
    list.appendChild(wrap);
  });
}

function renderTagSelection(container, selected = [], optionClass = "tag-option") {
  if (!container) return;
  const chosen = new Set(selected);
  container.innerHTML = "";
  if (!state.tags.length) {
    container.innerHTML = '<div class="text-xs opacity-70">No tags available.</div>';
    return;
  }
  state.tags
    .slice()
    .sort((a, b) => (a.priority || 0) - (b.priority || 0) || a.name.localeCompare(b.name))
    .forEach(tag => {
      const label = document.createElement("label");
      label.className = "flex items-center justify-between gap-2 bg-slate-900/40 rounded px-2 py-1";
      const input = document.createElement("input");
      input.type = "checkbox";
      input.value = tag.id;
      input.checked = chosen.has(tag.id);
      input.className = `rounded ${optionClass}`;
      const span = document.createElement("span");
      span.className = "flex items-center gap-2 text-xs";
      const dot = document.createElement("span");
      dot.className = "inline-block w-3 h-3 rounded-full";
      dot.style.backgroundColor = tag.color || "#38bdf8";
      span.appendChild(dot);
      const name = document.createElement("span");
      name.textContent = tag.name;
      span.appendChild(name);
      label.appendChild(input);
      label.appendChild(span);
      container.appendChild(label);
    });
}

function questMatchesFilters(q) {
  if (!questFilterSelection || questFilterSelection === QUEST_FILTER_ALL) return true;
  const questTags = Array.isArray(q.tags) ? q.tags : [];
  if (questFilterSelection === QUEST_FILTER_CUSTOM) {
    if (!state.settings.customFilterTags.length) return false;
    return questTags.some(id => state.settings.customFilterTags.includes(id));
  }
  return questTags.includes(questFilterSelection);
}

function noteMatchesFilters(note) {
  if (!noteFilterSelection || noteFilterSelection === QUEST_FILTER_ALL) return true;
  const noteTags = Array.isArray(note.tags) ? note.tags : [];
  if (noteFilterSelection === QUEST_FILTER_CUSTOM) {
    if (!state.settings.customFilterTags.length) return false;
    return noteTags.some(id => state.settings.customFilterTags.includes(id));
  }
  return noteTags.includes(noteFilterSelection);
}

function renderQuestFilters() {
  const container = el("quest-filter-container");
  if (!container) return;
  container.innerHTML = "";
  const filters = [
    { id: QUEST_FILTER_ALL, label: "All" },
    { id: QUEST_FILTER_CUSTOM, label: "Custom" }
  ];
  state.tags
    .slice()
    .sort((a, b) => (a.priority || 0) - (b.priority || 0) || a.name.localeCompare(b.name))
    .forEach(tag => {
      filters.push({ id: tag.id, label: tag.name });
    });
  if (!filters.some(f => f.id === questFilterSelection)) {
    questFilterSelection = QUEST_FILTER_ALL;
  }
  const label = document.createElement("label");
  label.className = "text-xs uppercase tracking-wide opacity-70";
  label.textContent = "Filter";
  container.appendChild(label);
  const select = document.createElement("select");
  select.className = "mt-1 px-3 py-2 rounded bg-slate-800 text-sm";
  filters.forEach(filter => {
    const option = document.createElement("option");
    option.value = filter.id;
    option.textContent = filter.label;
    select.appendChild(option);
  });
  select.value = questFilterSelection;
  select.onchange = e => {
    questFilterSelection = e.target.value;
    renderQuestList();
  };
  container.appendChild(select);
  if (questFilterSelection === QUEST_FILTER_CUSTOM && !state.settings.customFilterTags.length) {
    const note = document.createElement("div");
    note.className = "text-xs opacity-60 mt-2";
    note.textContent = "No tags assigned to Custom filter.";
    container.appendChild(note);
  }
}

function renderNoteFilters() {
  const container = el("note-filter-container");
  if (!container) return;
  container.innerHTML = "";
  const filters = [
    { id: QUEST_FILTER_ALL, label: "All" },
    { id: QUEST_FILTER_CUSTOM, label: "Custom" }
  ];
  state.tags
    .slice()
    .sort((a, b) => (a.priority || 0) - (b.priority || 0) || a.name.localeCompare(b.name))
    .forEach(tag => {
      filters.push({ id: tag.id, label: tag.name });
    });
  if (!filters.some(f => f.id === noteFilterSelection)) {
    noteFilterSelection = QUEST_FILTER_ALL;
  }
  const label = document.createElement("label");
  label.className = "text-xs uppercase tracking-wide opacity-70";
  label.textContent = "Filter";
  container.appendChild(label);
  const select = document.createElement("select");
  select.className = "mt-1 px-3 py-2 rounded bg-slate-800 text-sm";
  filters.forEach(filter => {
    const option = document.createElement("option");
    option.value = filter.id;
    option.textContent = filter.label;
    select.appendChild(option);
  });
  select.value = noteFilterSelection;
  select.onchange = e => {
    noteFilterSelection = e.target.value;
    renderNotes();
  };
  container.appendChild(select);
  if (noteFilterSelection === QUEST_FILTER_CUSTOM && !state.settings.customFilterTags.length) {
    const note = document.createElement("div");
    note.className = "text-xs opacity-60 mt-2";
    note.textContent = "No tags assigned to Custom filter.";
    container.appendChild(note);
  }
}

function renderQuestList() {
  const qlist = el("quest-list");
  if (!qlist) return;
  qlist.innerHTML = "";
  const dayBoundary = getDayBoundaryStart();
  const quests = state.quests
    .slice()
    .sort((a, b) => {
      const tagA = (a.tags || [])[0];
      const tagB = (b.tags || [])[0];
      const ta = state.tags.find(t => t.id === tagA)?.priority ?? Infinity;
      const tb = state.tags.find(t => t.id === tagB)?.priority ?? Infinity;
      if (ta === tb) return (a.title || "").localeCompare(b.title || "");
      return ta - tb;
    })
    .filter(questMatchesFilters);
  if (!quests.length) {
    qlist.innerHTML = '<div class="text-sm opacity-70">No quests found.</div>';
    return;
  }
  quests.forEach(q => {
    const node = el("tpl-quest").content.cloneNode(true);
    const card = node.querySelector(".q-card");
    node.querySelector(".q-title").textContent = q.title;
    node.querySelector(".q-xp").textContent = q.xp >= 0 ? `+${q.xp}` : q.xp;
    const statSpan = node.querySelector(".q-tag-stat");
    if (q.stats && q.stats.length) {
      statSpan.textContent = q.stats.map(s => s.name).join(", ");
      statSpan.classList.remove("hidden");
    } else {
      statSpan.classList.add("hidden");
    }
    const skillSpan = node.querySelector(".q-tag-skill");
    if (q.skills && q.skills.length) {
      skillSpan.textContent = q.skills.map(sk => sk.name).join(", ");
      skillSpan.classList.remove("hidden");
    } else {
      skillSpan.classList.add("hidden");
    }
    const tagWrap = node.querySelector(".q-tag-pills");
    tagWrap.innerHTML = "";
    (q.tags || []).forEach(id => {
      const tag = state.tags.find(t => t.id === id);
      if (!tag) return;
      const pill = document.createElement("span");
      pill.className = "px-2 py-0.5 rounded text-xs text-slate-900";
      pill.style.backgroundColor = tag.color || "#38bdf8";
      pill.textContent = tag.name;
      tagWrap.appendChild(pill);
    });
    tagWrap.classList.toggle("hidden", !tagWrap.childElementCount);
    if (q.anti) {
      card.classList.add("bg-rose-900");
    }
    const dueEl = node.querySelector(".q-due");
    if (q.due) {
      const dueText = formatQuestDue(q.due);
      dueEl.textContent = dueText ? `Due: ${dueText}` : "";
      dueEl.classList.toggle("hidden", !dueText);
    } else {
      dueEl.classList.add("hidden");
    }
    const lastEl = node.querySelector(".q-last-completed");
    if (q.lastCompletedAt) {
      const completed = new Date(q.lastCompletedAt);
      lastEl.textContent = `Last completed: ${completed.toLocaleString()}`;
      lastEl.classList.remove("hidden");
    } else {
      lastEl.classList.add("hidden");
    }
    if (q.lastCompletedAt && q.lastCompletedAt >= dayBoundary) {
      card.classList.add("completed-today");
    }
    const notesEl = node.querySelector(".q-notes");
    notesEl.textContent = q.notes || "";
    notesEl.style.borderLeft = `4px solid ${q.noteColor || "#0ea5e9"}`;
    notesEl.style.backgroundColor = hexToRgba(q.noteColor || "#0ea5e9", 0.2);
    notesEl.style.paddingLeft = "0.5rem";
    const completeBtn = node.querySelector(".q-complete");
    attachHoldButton(completeBtn, {
      variant: "quest",
      onComplete: () => completeQuest(q.id),
      getDrops: result => createQuestDrops(result)
    });
    node.querySelector(".q-delete").onclick = () => deleteQuest(q.id);
    node.querySelector(".q-edit").onclick = () => startEdit(q.id);
    qlist.appendChild(node);
  });
}

function renderNotes() {
  const list = el("note-list");
  if (!list) return;
  list.innerHTML = "";
  const notes = state.notes
    .slice()
    .sort((a, b) => (b.updatedAt || 0) - (a.updatedAt || 0))
    .filter(noteMatchesFilters);
  if (!notes.length) {
    list.innerHTML = '<div class="text-sm opacity-70">No journal entries yet.</div>';
    return;
  }
  notes.forEach(note => {
    const card = document.createElement("div");
    card.className = "rounded-xl p-3 ring-1 ring-white/10";
    card.style.backgroundColor = hexToRgba(note.color || "#0ea5e9", 0.18);
    const header = document.createElement("div");
    header.className = "flex justify-between items-start mb-2";
    const titleWrap = document.createElement("div");
    const title = document.createElement("div");
    title.className = "font-semibold";
    title.textContent = note.title || "Untitled";
    const meta = document.createElement("div");
    meta.className = "text-xs opacity-70";
    meta.textContent = new Date(note.updatedAt || Date.now()).toLocaleString();
    titleWrap.appendChild(title);
    titleWrap.appendChild(meta);
    header.appendChild(titleWrap);
    const actions = document.createElement("div");
    actions.className = "flex gap-2";
    const editBtn = document.createElement("button");
    editBtn.className = "text-xs px-2 py-1 rounded bg-sky-700 hover:bg-sky-600";
    editBtn.textContent = "Edit";
    editBtn.onclick = () => startNoteEdit(note.id);
    const deleteBtn = document.createElement("button");
    deleteBtn.className = "text-xs px-2 py-1 rounded bg-rose-700 hover:bg-rose-600";
    deleteBtn.textContent = "Delete";
    deleteBtn.onclick = () => deleteNote(note.id);
    actions.appendChild(editBtn);
    actions.appendChild(deleteBtn);
    header.appendChild(actions);
    card.appendChild(header);
    const body = document.createElement("div");
    body.className = "text-sm whitespace-pre-wrap";
    body.textContent = note.body || "";
    card.appendChild(body);
    const tagWrap = document.createElement("div");
    tagWrap.className = "flex flex-wrap gap-1 mt-2";
    (note.tags || []).forEach(id => {
      const tag = state.tags.find(t => t.id === id);
      if (!tag) return;
      const pill = document.createElement("span");
      pill.className = "px-2 py-0.5 rounded text-xs text-slate-900";
      pill.style.backgroundColor = tag.color || "#38bdf8";
      pill.textContent = tag.name;
      tagWrap.appendChild(pill);
    });
    if (tagWrap.childElementCount) card.appendChild(tagWrap);
    list.appendChild(card);
  });
}

function startNoteEdit(id) {
  const note = state.notes.find(n => n.id === id);
  if (!note) return;
  editingNoteId = id;
  const form = el("note-form");
  form.classList.remove("hidden");
  el("note-title").value = note.title || "";
  el("note-body").value = note.body || "";
  el("note-color").value = note.color || "#0ea5e9";
  renderTagSelection(el("note-tag-options"), note.tags || [], "note-tag-option");
  el("btn-save-note").textContent = "Update Entry";
}

function deleteNote(id) {
  const idx = state.notes.findIndex(n => n.id === id);
  if (idx === -1) return;
  state.notes.splice(idx, 1);
  if (editingNoteId === id) {
    editingNoteId = null;
    el("note-form").reset();
    el("note-form").classList.add("hidden");
    renderTagSelection(el("note-tag-options"), [], "note-tag-option");
    el("note-color").value = "#0ea5e9";
    el("btn-save-note").textContent = "Save Entry";
  }
  save();
  renderNotes();
  renderNoteFilters();
}

function renderCustomFilterSettings() {
  const container = el("custom-filter-settings");
  if (!container) return;
  container.innerHTML = "";
  if (!state.tags.length) {
    container.innerHTML = '<div class="text-xs opacity-70">Create tags to build a custom filter.</div>';
    return;
  }
  state.tags
    .slice()
    .sort((a, b) => (a.priority || 0) - (b.priority || 0) || a.name.localeCompare(b.name))
    .forEach(tag => {
      const label = document.createElement("label");
      label.className = "flex items-center justify-between gap-2 bg-slate-900/40 rounded px-2 py-1";
      const input = document.createElement("input");
      input.type = "checkbox";
      input.value = tag.id;
      input.checked = state.settings.customFilterTags.includes(tag.id);
      input.className = "custom-filter-option rounded";
      input.onchange = e => {
        if (e.target.checked) {
          if (!state.settings.customFilterTags.includes(tag.id)) state.settings.customFilterTags.push(tag.id);
        } else {
          state.settings.customFilterTags = state.settings.customFilterTags.filter(t => t !== tag.id);
        }
        save();
        renderQuestFilters();
        renderNoteFilters();
        renderQuestList();
        renderNotes();
      };
      const span = document.createElement("span");
      span.className = "flex items-center gap-2 text-xs";
      const dot = document.createElement("span");
      dot.className = "inline-block w-3 h-3 rounded-full";
      dot.style.backgroundColor = tag.color || "#38bdf8";
      span.appendChild(dot);
      const name = document.createElement("span");
      name.textContent = tag.name;
      span.appendChild(name);
      label.appendChild(input);
      label.appendChild(span);
      container.appendChild(label);
    });
}

function pruneDungeonChat() {
  if (!state.dungeon) return;
  if (!Array.isArray(state.dungeon.recentMonsters)) state.dungeon.recentMonsters = [];
  const hasCodexEntries = Array.isArray(state.dungeon.chat)
    ? state.dungeon.chat.some(entry => entry && entry.monsterKey === CODEX_KEY)
    : false;
  let keepKeys = state.dungeon.recentMonsters.slice(-2);
  if (hasCodexEntries && !keepKeys.includes(CODEX_KEY)) {
    keepKeys.unshift(CODEX_KEY);
  }
  state.dungeon.recentMonsters = keepKeys.slice();
  state.dungeon.chat.sort((a, b) => (a.createdAt || 0) - (b.createdAt || 0));
  state.dungeon.chat = state.dungeon.chat.filter(entry => {
    if (entry.monsterKey === CODEX_KEY) return true;
    if (!entry.monsterKey) {
      if (keepKeys.length) {
        entry.monsterKey = keepKeys[keepKeys.length - 1];
      }
      return true;
    }
    return keepKeys.includes(entry.monsterKey);
  });
  keepKeys.forEach(key => {
    if (key === CODEX_KEY) {
      const codexEntries = state.dungeon.chat.filter(entry => entry.monsterKey === CODEX_KEY);
      if (codexEntries.length > 12) {
        let removed = 0;
        state.dungeon.chat = state.dungeon.chat.filter(entry => {
          if (entry.monsterKey !== CODEX_KEY) return true;
          if (removed < codexEntries.length - 12) {
            removed++;
            return false;
          }
          return true;
        });
      }
      return;
    }
    let count = 0;
    state.dungeon.chat.forEach(entry => {
      if (entry.monsterKey === key) count++;
    });
    if (count > 7) {
      let removed = 0;
      state.dungeon.chat = state.dungeon.chat.filter(entry => {
        if (entry.monsterKey !== key) return true;
        if (removed < count - 7) {
          removed++;
          return false;
        }
        return true;
      });
    }
  });
}

function addDungeonChatBlock(title, lines = [], options = {}) {
  if (!state.dungeon) return;
  const normalizedLines = Array.isArray(lines) ? lines : [String(lines)];
  const recent = Array.isArray(state.dungeon.recentMonsters) ? state.dungeon.recentMonsters : [];
  const lastKey = recent[recent.length - 1] || null;
  let monsterKey = options.monsterKey || state.dungeon.activeMonsterKey || lastKey || crypto.randomUUID();
  if (!recent.includes(monsterKey)) {
    recent.push(monsterKey);
    state.dungeon.recentMonsters = recent;
  }
  state.dungeon.chat.push({
    id: crypto.randomUUID(),
    title,
    lines: normalizedLines,
    monsterKey,
    createdAt: options.createdAt || Date.now()
  });
  pruneDungeonChat();
}

function formatNumber(value) {
  if (typeof value !== "number" || Number.isNaN(value)) return value;
  return value.toLocaleString();
}

function formatSigned(value) {
  if (typeof value !== "number" || Number.isNaN(value)) return value;
  if (value > 0) return `+${formatNumber(value)}`;
  if (value < 0) return `-${formatNumber(Math.abs(value))}`;
  return "0";
}

function spawnHoldSparks(rect, variant = "quest", colors) {
  if (!holdFxLayer || !rect) return;
  const cx = rect.left + rect.width / 2;
  const cy = rect.top + rect.height / 2;
  const count = 24;
  const palette = Array.isArray(colors) && colors.length === 2
    ? colors
    : variant === "attack"
      ? ["#f87171", "#fb7185"]
      : ["#5cf4ff", "#3bd1c8"];
  for (let i = 0; i < count; i++) {
    const angle = Math.random() * Math.PI * 2;
    const r0 = Math.random() * 8 - 4;
    const r1 = 70 + Math.random() * 90;
    const x0 = cx + Math.cos(angle) * r0;
    const y0 = cy + Math.sin(angle) * r0;
    const x1 = cx + Math.cos(angle) * r1;
    const y1 = cy + Math.sin(angle) * r1;
    const spark = document.createElement("span");
    spark.className = "spark";
    spark.style.left = `${x0}px`;
    spark.style.top = `${y0}px`;
    spark.style.setProperty("--x0", "-50%");
    spark.style.setProperty("--y0", "-50%");
    spark.style.setProperty("--x1", `${x1 - x0 - 50}px`);
    spark.style.setProperty("--y1", `${y1 - y0 - 50}px`);
    spark.style.setProperty("--spark-color-1", palette[0]);
    spark.style.setProperty("--spark-color-2", palette[1]);
    holdFxLayer.appendChild(spark);
    setTimeout(() => spark.remove(), 720);
  }
}

function spawnRewardDrops(rect, drops = []) {
  if (!holdRewardsLayer || !rect || !drops.length) return;
  const cx = rect.left + rect.width / 2;
  const cy = rect.top + rect.height / 2;
  const spacing = 34;
  const startOffset = -((drops.length - 1) / 2) * spacing;
  drops.forEach((drop, idx) => {
    if (!drop || !drop.text) return;
    const el = document.createElement("div");
    el.className = `drop ${drop.cls || ""}`.trim();
    el.textContent = drop.text;
    const jitterX = Math.random() * 16 - 8;
    const jitterY = Math.random() * 10 - 5;
    const driftX = Math.random() * 20 - 10;
    const fall = 110 + Math.random() * 60;
    const baseY = startOffset + idx * spacing;
    el.style.setProperty("--cx", `${cx}px`);
    el.style.setProperty("--cy", `${cy}px`);
    el.style.setProperty("--x", `${jitterX}px`);
    el.style.setProperty("--y", `${baseY + jitterY}px`);
    el.style.setProperty("--x2", `${jitterX + driftX}px`);
    el.style.setProperty("--y2", `${baseY + jitterY + fall}px`);
    holdRewardsLayer.appendChild(el);
    setTimeout(() => el.remove(), 2600);
  });
}

function triggerHoldFeedback({ rect, drops, variant, sparkColors, outcome, onAfter }) {
  if (!rect) return;
  spawnHoldSparks(rect, variant, sparkColors);
  if (Array.isArray(drops) && drops.length) {
    spawnRewardDrops(rect, drops);
  }
  if (typeof onAfter === "function") {
    onAfter({ rect, drops, outcome });
  }
}

function attachHoldButton(btn, config = {}) {
  if (!btn) return;
  const duration = config.duration || HOLD_BUTTON_DURATION;
  const fill = btn.querySelector(".fill");
  const ring = btn.querySelector(".pop-ring");
  let rafId = 0;
  let startTs = 0;
  let isHolding = false;
  let completed = false;
  let keyHolding = false;
  let pointerId = null;

  function resetVisual() {
    startTs = 0;
    if (fill) fill.style.width = "0%";
    btn.classList.remove("holding");
  }

  function cancelHold() {
    isHolding = false;
    cancelAnimationFrame(rafId);
    if (!completed) {
      resetVisual();
    }
  }

  function finishHold() {
    isHolding = false;
    completed = true;
    cancelAnimationFrame(rafId);
    const rect = config.getRect ? config.getRect(btn) : btn.getBoundingClientRect();
    if (fill) fill.style.width = "100%";
    btn.classList.remove("holding");
    if (ring) {
      ring.classList.remove("show");
      void ring.offsetWidth;
      ring.classList.add("show");
    }
    btn.style.animation = "none";
    void btn.offsetWidth;
    btn.style.animation = "hold-pop 0.28s ease-out";
    const outcome = config.onComplete ? config.onComplete({ rect, button: btn }) : null;
    const drops = config.getDrops ? config.getDrops(outcome) : [];
    if (outcome !== undefined && outcome !== null || (Array.isArray(drops) && drops.length)) {
      triggerHoldFeedback({
        rect,
        drops,
        variant: config.variant || btn.dataset.variant || "quest",
        sparkColors: config.sparkColors,
        outcome,
        onAfter: config.onAfter
      });
    }
    setTimeout(() => {
      btn.style.animation = "none";
      if (btn.isConnected) resetVisual();
    }, 280);
  }

  function step(timestamp) {
    if (!isHolding) return;
    if (!startTs) startTs = timestamp;
    const progress = Math.min(1, (timestamp - startTs) / duration);
    if (fill) fill.style.width = `${(progress * 100).toFixed(2)}%`;
    if (progress >= 1) {
      finishHold();
    } else {
      rafId = requestAnimationFrame(step);
    }
  }

  function beginHold() {
    if (isHolding) return;
    isHolding = true;
    completed = false;
    startTs = 0;
    btn.classList.add("holding");
    rafId = requestAnimationFrame(step);
  }

  btn.addEventListener("pointerdown", e => {
    if (e.button !== undefined && e.button !== 0) return;
    pointerId = e.pointerId;
    beginHold();
    btn.setPointerCapture?.(pointerId);
    e.preventDefault();
  });

  btn.addEventListener("pointerup", () => {
    if (!isHolding) return;
    btn.releasePointerCapture?.(pointerId);
    if (!completed) {
      cancelHold();
    }
  });

  btn.addEventListener("pointerleave", () => {
    if (isHolding && !completed) cancelHold();
  });

  btn.addEventListener("pointercancel", () => {
    if (isHolding && !completed) cancelHold();
  });

  btn.addEventListener("keydown", e => {
    if (e.code !== "Space" && e.code !== "Enter") return;
    if (keyHolding) return;
    keyHolding = true;
    beginHold();
    e.preventDefault();
  });

  btn.addEventListener("keyup", e => {
    if (e.code !== "Space" && e.code !== "Enter") return;
    keyHolding = false;
    if (!completed) cancelHold();
  });
}

function createHoldButtonElement(label, variant = "quest") {
  const btn = document.createElement("button");
  btn.type = "button";
  btn.className = "hold-btn";
  btn.dataset.variant = variant;
  btn.setAttribute("aria-label", `Hold to ${label.toLowerCase()}`);
  btn.innerHTML = `<span class="track" aria-hidden="true"></span>
    <span class="fill" aria-hidden="true"></span>
    <span class="label-text"></span>
    <span class="pop-ring" aria-hidden="true"></span>`;
  const labelEl = btn.querySelector(".label-text");
  if (labelEl) labelEl.textContent = label;
  return btn;
}

function createQuestDrops(result) {
  if (!result) return [];
  const drops = [];
  if (typeof result.xp === "number") {
    drops.push({ text: `${formatSigned(result.xp)} XP`, cls: "xp" });
  }
  if (typeof result.gold === "number") {
    drops.push({ text: `${formatSigned(result.gold)} Gold`, cls: "gold" });
  }
  (Array.isArray(result.stats) ? result.stats : [])
    .filter(entry => typeof entry.points === "number" && entry.points !== 0)
    .forEach(entry => {
      drops.push({ text: `${entry.name} ${formatSigned(entry.points)}`, cls: "stat" });
    });
  (Array.isArray(result.skills) ? result.skills : [])
    .filter(entry => typeof entry.points === "number" && entry.points !== 0)
    .forEach(entry => {
      drops.push({ text: `${entry.name} ${formatSigned(entry.points)}`, cls: "skill" });
    });
  return drops;
}

function createAttackDrops(result) {
  if (!result) return [];
  const drops = [];
  const rollValue = Array.isArray(result.rollHistory) && result.rollHistory.length
    ? result.rollHistory[result.rollHistory.length - 1]
    : result.roll;
  if (typeof rollValue === "number") {
    drops.push({ text: `Dice ${formatSigned(rollValue)}`, cls: "dice" });
  }
  if (result.missed) {
    drops.push({ text: "Damage 0", cls: "damage" });
    drops.push({ text: "Miss!", cls: "miss" });
    return drops;
  }
  if (typeof result.totalDamage === "number") {
    drops.push({ text: `Damage ${formatSigned(result.totalDamage)}`, cls: "damage" });
  }
  if (result.critical) {
    drops.push({ text: "Critical!", cls: "dmg" });
  } else if (result.abilityTriggered) {
    drops.push({ text: result.abilityText || "Absorbed!", cls: "dmg" });
  }
  return drops;
}

function addInboxMessage({ id, title, body, source = "system", pinned = false, notify = true, timestamp = Date.now(), dayKey = null }) {
  if (!Array.isArray(state.inbox)) state.inbox = [];
  const entry = {
    id: id || crypto.randomUUID(),
    title: title || "Message",
    body: body || "",
    source,
    timestamp,
    read: pinned ? true : false,
    pinned,
    dayKey
  };
  const existingIdx = state.inbox.findIndex(msg => msg.id === entry.id);
  if (existingIdx !== -1) {
    state.inbox[existingIdx] = { ...state.inbox[existingIdx], ...entry };
  } else {
    state.inbox.push(entry);
    if (state.inbox.length > 200) {
      state.inbox = state.inbox.slice(-200);
    }
  }
  save();
  updateInboxBadge();
  if (!pinned && notify) {
    sendNotification(entry.title, entry.body);
  }
  const view = el("view-inbox");
  if (view && !view.classList.contains("hidden")) {
    renderInbox();
  }
  return entry.id;
}

function renderInbox() {
  const list = el("inbox-list");
  if (!list) return;
  list.innerHTML = "";
  if (!state.inbox.length) {
    list.innerHTML = '<div class="text-xs opacity-70">No messages yet.</div>';
    return;
  }
  const messages = state.inbox
    .slice()
    .sort((a, b) => (b.timestamp || 0) - (a.timestamp || 0));
  const pinned = messages.filter(msg => msg.pinned);
  const regular = messages.filter(msg => !msg.pinned);
  const buildCard = msg => {
    const card = document.createElement("div");
    card.className = "rounded-xl bg-slate-900/40 p-3 ring-1 ring-white/10";
    if (!msg.read || msg.justOpened) {
      card.classList.add("ring-emerald-500/50");
    }
    if (msg.pinned) {
      card.classList.add("inbox-card-pinned");
    }
    const header = document.createElement("div");
    header.className = "flex items-start justify-between mb-2";
    const titleWrap = document.createElement("div");
    titleWrap.innerHTML = `<div class=\"font-semibold\">${msg.title}</div><div class=\"text-xs opacity-70\">${new Date(msg.timestamp || Date.now()).toLocaleString()}</div>`;
    header.appendChild(titleWrap);
    const source = document.createElement("span");
    source.className = "text-xs uppercase tracking-wide opacity-60";
    source.textContent = msg.source || "system";
    header.appendChild(source);
    card.appendChild(header);
    const body = document.createElement("div");
    body.className = "whitespace-pre-wrap text-sm";
    body.textContent = msg.body || "";
    card.appendChild(body);
    return card;
  };
  if (pinned.length) {
    const section = document.createElement("div");
    section.className = "inbox-section";
    const label = document.createElement("span");
    label.className = "inbox-section-label";
    label.textContent = "Pinned";
    section.appendChild(label);
    pinned.forEach(msg => {
      section.appendChild(buildCard(msg));
    });
    list.appendChild(section);
  }
  if (regular.length) {
    regular.forEach(msg => list.appendChild(buildCard(msg)));
  } else if (!pinned.length) {
    list.innerHTML = '<div class="text-xs opacity-70">No messages yet.</div>';
  }
}
function sendNotification(title, body) {
  if (!state.settings.notificationsEnabled) return;
  if (!("Notification" in window)) return;
  if (Notification.permission === "granted") {
    try {
      new Notification(title || "TaskForge", {
        body: body || "",
        icon: "Sprites/Commoner.png"
      });
    } catch (err) {
      console.warn("Notification error", err);
    }
  } else if (Notification.permission === "default") {
    Notification.requestPermission().then(result => {
      if (result === "granted") {
        sendNotification(title, body);
      } else if (result === "denied") {
        state.settings.notificationsEnabled = false;
        save();
        updateNotificationUI();
      }
    });
  }
}
function updateDailyMail() {
  const dailyTagIds = getDailyTagIds();
  const dayBoundary = getDayBoundaryStart();
  const questDay = getQuestDayDate();
  const dayKey = formatDateKey(questDay);
  const dateLabel = new Date(dayBoundary).toLocaleDateString(undefined, {
    weekday: "long",
    month: "short",
    day: "numeric"
  });
  const lines = [`Daily Quests for ${dateLabel}`, ""];
  if (!dailyTagIds.length) {
    lines.push('No "Daily" tag found. Create one to track repeating quests.');
  } else {
    const incomplete = state.quests
      .filter(q => questHasDailyTag(q, dailyTagIds))
      .filter(q => !(q.lastCompletedAt && q.lastCompletedAt >= dayBoundary))
      .sort((a, b) => (a.title || "").localeCompare(b.title || ""));
    lines.push("Incomplete:");
    if (incomplete.length) {
      incomplete.forEach(q => {
        const dueText = q.due ? formatQuestDue(q.due) : "";
        lines.push(`â€¢ ${q.title}${dueText ? ` â€” due ${dueText}` : ""}`);
      });
    } else {
      lines.push("â€¢ All daily quests are complete!");
    }
    const completed = state.log
      .filter(l => l.completedAt && l.completedAt >= dayBoundary)
      .filter(l => questHasDailyTag(l, dailyTagIds))
      .sort((a, b) => (a.completedAt || 0) - (b.completedAt || 0));
    lines.push("", "Completed:");
    if (completed.length) {
      completed.forEach(l => {
        const time = l.completedAt
          ? new Date(l.completedAt).toLocaleTimeString([], { hour: "numeric", minute: "2-digit" })
          : "";
        lines.push(`â€¢ ${l.title}${time ? ` (${time})` : ""}`);
      });
    } else {
      lines.push("â€¢ None yet.");
    }
  }
  const body = lines.join("\n").trimEnd();
  const existing = state.inbox.find(msg => msg.id === DAILY_MAIL_ID);
  if (existing && existing.body === body && existing.dayKey === dayKey && existing.timestamp === dayBoundary) {
    return;
  }
  addInboxMessage({
    id: DAILY_MAIL_ID,
    title: "Daily Mail",
    body,
    source: "Daily Mail",
    pinned: true,
    notify: false,
    timestamp: dayBoundary,
    dayKey
  });
}
function checkQuestReminders() {
  const questDay = getQuestDayDate();
  let mutated = false;
  state.quests.forEach(q => {
    if (!q.due) return;
    const dueDate = parseDateOnly(q.due);
    if (!dueDate) return;
    if (!q.reminderTracker || typeof q.reminderTracker !== "object") q.reminderTracker = {};
    const diffDays = Math.round((dueDate.getTime() - questDay.getTime()) / MS_PER_DAY);
    if (diffDays === 1 && q.reminderTracker.dayBefore !== q.due) {
      q.reminderTracker.dayBefore = q.due;
      addInboxMessage({
        title: `Quest tomorrow: ${q.title}`,
        body: `"${q.title}" is due tomorrow (${formatQuestDue(q.due)}).`,
        source: "Quest Reminder",
        notify: true
      });
      mutated = true;
    }
    if (diffDays === 0 && q.reminderTracker.dayOf !== q.due) {
      q.reminderTracker.dayOf = q.due;
      addInboxMessage({
        title: `Quest today: ${q.title}`,
        body: `"${q.title}" is due today (${formatQuestDue(q.due)}).`,
        source: "Quest Reminder",
        notify: true
      });
      mutated = true;
    }
    if (diffDays !== 1 && q.reminderTracker.dayBefore === q.due) {
      delete q.reminderTracker.dayBefore;
      mutated = true;
    }
    if (diffDays !== 0 && q.reminderTracker.dayOf === q.due) {
      delete q.reminderTracker.dayOf;
      mutated = true;
    }
  });
  if (mutated) save();
}
function updateNotificationUI() {
  const button = el("btn-toggle-notifications");
  const status = el("notification-status");
  if (!button || !status) return;
  if (!("Notification" in window)) {
    button.textContent = "Unsupported";
    button.disabled = true;
    status.textContent = "Notifications are not available in this browser.";
    return;
  }
  button.disabled = false;
  const enabled = !!state.settings.notificationsEnabled;
  button.textContent = enabled ? "Disable" : "Enable";
  const permission = Notification.permission;
  if (permission === "denied") {
    status.textContent = "Permission denied. Enable notifications in your browser settings.";
  } else if (permission === "default") {
    status.textContent = enabled
      ? "Awaiting permission from the browser."
      : "Enable to receive quest reminders as push notifications.";
  } else {
    status.textContent = enabled ? "Notifications enabled." : "Notifications disabled.";
  }
}
function registerPullToRefresh() {
  if (!('ontouchstart' in window) && !(navigator.maxTouchPoints > 0)) return;
  let startY = null;
  let triggered = false;
  const threshold = 110;
  document.addEventListener(
    "touchstart",
    e => {
      const scrollTop = document.scrollingElement ? document.scrollingElement.scrollTop : 0;
      if (scrollTop > 0) {
        startY = null;
        triggered = false;
        return;
      }
      startY = e.touches[0]?.clientY ?? null;
      triggered = false;
    },
    { passive: true }
  );
  document.addEventListener(
    "touchmove",
    e => {
      if (startY === null || triggered) return;
      const currentY = e.touches[0]?.clientY ?? 0;
      if (currentY - startY > threshold) {
        triggered = true;
        location.reload();
      }
    },
    { passive: true }
  );
  document.addEventListener(
    "touchend",
    () => {
      startY = null;
      triggered = false;
    },
    { passive: true }
  );
}

function updateInboxBadge() {
  const badge = el("inbox-badge");
  if (!badge) return;
  const unread = state.inbox.filter(msg => !msg.read && !msg.pinned).length;
  if (unread > 0) {
    badge.textContent = unread > 99 ? "99+" : unread;
    badge.classList.remove("hidden");
  } else {
    badge.classList.add("hidden");
  }
}

function openInbox() {
  show("view-inbox");
  let changed = false;
  state.inbox.forEach(msg => {
    if (!msg.read && !msg.pinned) {
      msg.read = true;
      msg.justOpened = true;
      changed = true;
    } else {
      msg.justOpened = false;
    }
  });
  renderInbox();
  state.inbox.forEach(msg => {
    if (Object.prototype.hasOwnProperty.call(msg, "justOpened")) delete msg.justOpened;
  });
  if (changed) save();
  updateInboxBadge();
}

function textModal(label, value, cb) {
  const div = document.createElement("div");
  div.innerHTML = `<label class="block mb-2">${label}</label>
    <input id="modal-input" class="w-full px-3 py-2 rounded bg-slate-800 mb-4" value="${value || ""}" />
    <div class="text-right space-x-2">
      <button id="modal-cancel" class="px-3 py-1 rounded bg-slate-700">Cancel</button>
      <button id="modal-ok" class="px-3 py-1 rounded bg-emerald-700">Save</button>
    </div>`;
  showModal(div);
  el("modal-ok").onclick = () => {
    const val = el("modal-input").value.trim();
    closeModal();
    cb(val);
  };
  el("modal-cancel").onclick = closeModal;
}

function tagModal(tag, cb) {
  const div = document.createElement("div");
  div.innerHTML = `<label class="block mb-2">Tag name</label>
    <input id="modal-tag-name" class="w-full px-3 py-2 rounded bg-slate-800 mb-2" value="${tag.name}" />
    <label class="block mb-2">Color</label>
    <input id="modal-tag-color" type="color" class="w-full h-10 p-0 rounded bg-slate-800 mb-2" value="${tag.color}" />
    <label class="block mb-2">Priority</label>
    <input id="modal-tag-priority" type="number" min="0" class="w-full px-3 py-2 rounded bg-slate-800 mb-4" value="${tag.priority || 0}" />
    <div class="text-right space-x-2">
      <button id="modal-cancel" class="px-3 py-1 rounded bg-slate-700">Cancel</button>
      <button id="modal-ok" class="px-3 py-1 rounded bg-emerald-700">Save</button>
    </div>`;
  showModal(div);
  el("modal-ok").onclick = () => {
    cb(el("modal-tag-name").value.trim(), el("modal-tag-color").value, +el("modal-tag-priority").value || 0);
    closeModal();
  };
  el("modal-cancel").onclick = closeModal;
}

function skillModal(skill, cb, editing = false) {
  const div = document.createElement("div");
  div.innerHTML = `<label class="block mb-2">Name</label>
    <input id="modal-skill-name" class="w-full px-3 py-2 rounded bg-slate-800 mb-2" value="${skill.name}" ${editing ? "disabled" : ""} />
    <label class="block mb-2">Priority (1-5)</label>
    <input id="modal-skill-priority" type="number" min="1" max="5" class="w-full px-3 py-2 rounded bg-slate-800 mb-2" value="${skill.priority || 1}" />
    <label class="block mb-2">Description</label>
    <textarea id="modal-skill-desc" class="w-full px-3 py-2 rounded bg-slate-800 mb-4" rows="3">${skill.desc || ""}</textarea>
    <div class="text-right space-x-2">
      <button id="modal-cancel" class="px-3 py-1 rounded bg-slate-700">Cancel</button>
      <button id="modal-ok" class="px-3 py-1 rounded bg-emerald-700">Save</button>
    </div>`;
  showModal(div);
  el("modal-ok").onclick = () => {
    const name = el("modal-skill-name").value.trim();
    const priority = +el("modal-skill-priority").value || 1;
    const desc = el("modal-skill-desc").value.trim();
    closeModal();
    cb({ name, priority, desc });
  };
  el("modal-cancel").onclick = closeModal;
}

function confirmModal(html, cb) {
  const div = document.createElement("div");
  div.innerHTML = `<div class="mb-4 text-sm">${html}</div>
    <div class="text-right space-x-2">
      <button id="modal-cancel" class="px-3 py-1 rounded bg-slate-700">Cancel</button>
      <button id="modal-ok" class="px-3 py-1 rounded bg-emerald-700">Confirm</button>
    </div>`;
  showModal(div);
  el("modal-ok").onclick = () => {
    closeModal();
    cb();
  };
  el("modal-cancel").onclick = closeModal;
}

function infoModal(html) {
  const div = document.createElement("div");
  div.innerHTML = `<div class="mb-4 text-sm">${html}</div>
    <div class="text-right">
      <button id="modal-ok" class="px-3 py-1 rounded bg-emerald-700">OK</button>
    </div>`;
  showModal(div);
  el("modal-ok").onclick = closeModal;
}

function itemModal(item, idx) {
  const div = document.createElement("div");
  div.innerHTML = `<img src="${item.img}" class="w-32 h-32 object-contain mx-auto mb-2"/>
    <h3 class="font-semibold mb-2 text-center">${item.title}</h3>
    <p class="text-sm mb-4">${item.desc}</p>
    <div class="text-right space-x-2">
      <button id="modal-cancel" class="px-3 py-1 rounded bg-slate-700">Close</button>
      ${item.consumable ? '<button id="modal-use" class="px-3 py-1 rounded bg-emerald-700">Consume</button>' : ''}
    </div>`;
  showModal(div);
  el("modal-cancel").onclick = closeModal;
  if (item.consumable) {
    el("modal-use").onclick = () => {
      state.inventory.splice(idx, 1);
      save();
      render();
       playItemSound(item);
      closeModal();
    };
  }
}
function spawnMonster() {
  const r = Math.random();
  let tier;
  if (r < 0.6) tier = 1;
  else if (r < 0.85) tier = 2;
  else if (r < 0.95) tier = 3;
  else tier = 4;
  const list = MONSTERS.filter(m => m.tier === tier);
  const template = list[rand(0, list.length - 1)];
  const base = monsterBaseHP(tier);
  const hp = Math.round(base * (0.7 + Math.random() * 0.6));
  const img =
    state.settings.monsterImages[template.name] ||
    `Sprites/${template.name}.png`;
  state.dungeon.current = {
    name: template.name,
    tier,
    weak: template.weak,
    resist: template.resist,
    ability: template.ability,
    rewardXp: template.rewardXp,
    rewardGold: template.rewardGold,
    baseHp: base,
    limit: template.limit || 30,
    hp,
    maxHp: hp,
    img,
    spawn: Date.now()
  };
  state.dungeon.activeMonsterKey = crypto.randomUUID();
  if (!Array.isArray(state.dungeon.recentMonsters)) state.dungeon.recentMonsters = [];
  state.dungeon.recentMonsters.push(state.dungeon.activeMonsterKey);
  pruneDungeonChat();
  state.dungeon.usedLogs = [];
  addDungeonChatBlock(`${template.name} Approaches`, [`Tier ${tier} Threat`, `HP: ${hp}`]);
  save();
  renderDungeon();
}
function attackDungeon(logId) {
  const log = state.log.find(l => l.id === logId);
  const m = state.dungeon.current;
  if (!log || !m) return null;
  const dieSides = log.diff >= 1000 ? 20 : 8;
  let roll = rand(1, dieSides);
  const rollHistory = [roll];
  const baseDamage = Math.max(0, log.xp / 100);
  let multiplier = 1;
  let additiveBonus = 0;
  const skillEntries = Array.isArray(log.skills) ? log.skills : [];
  const statEntries = Array.isArray(log.stats) ? log.stats : [];
  skillEntries.forEach(sk => {
    if (m.weak.includes(sk.name)) {
      additiveBonus += state.player.skills[sk.name] || 0;
      multiplier *= 1.15;
    }
    if (m.resist.includes(sk.name)) {
      multiplier *= 0.85;
    }
  });
  statEntries.forEach(st => {
    if (m.weak.includes(st.name)) {
      additiveBonus += state.player.mainstats[st.name] || 0;
      multiplier *= 1.15;
    }
    if (m.resist.includes(st.name)) {
      multiplier *= 0.85;
    }
  });
  const baseValue = Math.floor(baseDamage);
  const damageAfterMultiplier = baseDamage * multiplier;
  const multiplierDelta = Math.floor(damageAfterMultiplier - baseDamage);
  const bonusValue = Math.floor(additiveBonus);
  let totalBeforeCrit = Math.max(0, damageAfterMultiplier + additiveBonus);
  let critExtra = 0;
  let totalDamage = Math.floor(totalBeforeCrit);
  const result = {
    logId,
    questTitle: log.title || "Unknown Quest",
    monsterName: m.name,
    dieSides,
    roll,
    rollHistory: rollHistory.slice(),
    missed: roll === 1,
    baseDamage: baseValue,
    multiplierDelta,
    bonusValue,
    totalDamage: 0,
    critical: false,
    abilityTriggered: false,
    abilityText: "",
    remainingHp: m.hp,
    maxHp: m.maxHp,
    monsterDefeated: false,
    xpGain: 0,
    goldGain: 0
  };
  if (!result.missed && roll === dieSides) {
    critExtra = totalDamage;
    totalDamage *= 2;
    result.critical = true;
  }
  const lines = [
    `Quest Used: ${result.questTitle}`,
    `Dice Roll (d${dieSides}): ${rollHistory.join(" â†’ ")}`
  ];
  if (result.missed) {
    lines.push("Attack Missed!");
    lines.push(`Monster HP: ${m.hp}/${m.maxHp}`);
    addDungeonChatBlock(`${state.player.name} Attacks`, lines);
    attackSound.play();
    state.dungeon.usedLogs.push(logId);
    save();
    renderDungeon();
    return result;
  }
  let abilityTriggered = false;
  if (m.ability === "heal5" && totalDamage > 0 && Math.random() < 0.05) {
    abilityTriggered = true;
    m.hp = Math.min(m.maxHp, m.hp + totalDamage);
    critExtra = 0;
    totalDamage = 0;
  } else {
    m.hp = Math.max(0, m.hp - totalDamage);
  }
  result.totalDamage = totalDamage;
  lines.push(`Base Damage: ${baseValue}`);
  lines.push(`Multiplier Impact: ${multiplierDelta >= 0 ? "+" : ""}${multiplierDelta}`);
  lines.push(`Bonus Damage: ${bonusValue >= 0 ? "+" : ""}${bonusValue}`);
  lines.push(`Critical Hit: +${critExtra}`);
  lines.push(`Total Damage: ${totalDamage}`);
  if (abilityTriggered) {
    const text = `${m.name} absorbs the blow and heals instead!`;
    lines.push(text);
    result.abilityTriggered = true;
    result.abilityText = text;
  }
  lines.push(`Monster HP: ${m.hp}/${m.maxHp}`);
  result.remainingHp = m.hp;
  addDungeonChatBlock(`${state.player.name} Attacks`, lines);
  attackSound.play();
  state.dungeon.usedLogs.push(logId);
  if (m.hp <= 0) {
    const base = m.baseHp || monsterBaseHP(m.tier);
    const xpGain = Math.max(0, (m.rewardXp || 0) + (m.maxHp - base) * 2);
    const goldGain = m.rewardGold || 0;
    addXP(xpGain);
    state.player.gold += goldGain;
    const newRun = state.dungeon.currentRun + 1;
    addDungeonChatBlock(`${m.name} Defeated`, [
      `Rewards Earned: ${xpGain} XP`,
      `Gold Found: ${goldGain}`,
      `Run Total: ${newRun}`
    ]);
    addInboxMessage({
      title: `${m.name} Defeated`,
      body: `Rewards Earned: ${xpGain} XP\nGold Found: ${goldGain}\nRun Total: ${newRun}`,
      source: "dungeon"
    });
    state.dungeon.currentRun = newRun;
    if (state.dungeon.currentRun > state.dungeon.highestRun)
      state.dungeon.highestRun = state.dungeon.currentRun;
    state.dungeon.current = null;
    result.monsterDefeated = true;
    result.xpGain = xpGain;
    result.goldGain = goldGain;
    save();
    render();
    setTimeout(() => {
      spawnMonster();
    }, 2000);
    return result;
  }
  save();
  renderDungeon();
  return result;
}
function renderDungeon() {
  if (!state.dungeon) return;
  pruneDungeonChat();
  const d = state.dungeon;
  el("dungeon-highest").textContent = d.highestRun || 0;
  el("dungeon-current").textContent = d.currentRun || 0;
  const mDiv = el("dungeon-monster");
  const logDiv = el("dungeon-log");
  const qDiv = el("dungeon-quests");
  const actDiv = el("dungeon-actions");
  if (dungeonTimer) clearInterval(dungeonTimer);
  mDiv.innerHTML = "";
  logDiv.innerHTML = "";
  const chatFragment = document.createDocumentFragment();
  d.chat.forEach(entry => {
    const block = document.createElement("div");
    block.className = "chat-block";
    const title = document.createElement("span");
    title.className = "chat-line font-semibold";
    title.textContent = entry.title;
    block.appendChild(title);
    (entry.lines || []).forEach(text => {
      const span = document.createElement("span");
      span.className = "chat-line";
      span.textContent = text;
      block.appendChild(span);
    });
    chatFragment.appendChild(block);
  });
  logDiv.appendChild(chatFragment);
  logDiv.scrollTop = logDiv.scrollHeight;
  qDiv.innerHTML = "";
  actDiv.innerHTML = "";
  if (!d.current) {
    const btn = document.createElement("button");
    btn.id = "btn-enter-dungeon";
    btn.className = "px-4 py-2 rounded bg-sky-700 hover:bg-sky-600";
    btn.textContent = "Enter Codex";
    btn.onclick = () => confirmModal("Enter the Codex?", spawnMonster);
    mDiv.appendChild(btn);
    return;
  }
  const m = d.current;
  mDiv.innerHTML = `<img src="${m.img}" class="w-32 h-32 object-contain mx-auto mb-2"/><div class="font-semibold">${m.name}</div><div class="text-xs mb-2">${m.weak.length ? "+" + m.weak.join("/") + " " : ""}${m.resist.length ? "&darr;" + m.resist.join("/") : ""}</div><div class="w-full bg-slate-800 h-3 rounded mb-1"><div class="bg-rose-700 h-3 rounded" style="width:${(m.hp / m.maxHp) * 100}%"></div></div><div class="text-sm mb-1">HP: ${m.hp}/${m.maxHp}</div><div id="dungeon-timer" class="text-xs mb-2"></div>`;
  const tDiv = mDiv.querySelector("#dungeon-timer");
  function upd() {
    const diff = m.spawn + m.limit * 24 * 60 * 60 * 1000 - Date.now();
    if (diff <= 0) {
      addDungeonChatBlock(`${m.name} Escapes`, ["Time limit reached."]);
      d.current = null;
      d.currentRun = 0;
      save();
      renderDungeon();
    } else {
      const days = Math.floor(diff / 86400000);
      const hrs = pad(Math.floor((diff % 86400000) / 3600000));
      const mins = pad(Math.floor((diff % 3600000) / 60000));
      const secs = pad(Math.floor((diff % 60000) / 1000));
      tDiv.textContent = `days until death: ${days}d ${hrs}h ${mins}m ${secs}s`;
    }
  }
  upd();
  dungeonTimer = setInterval(upd, 1000);
  qDiv.innerHTML = "<h3 class=\"font-semibold mb-2\">Completed Quests</h3>";
  const quests = state.log
    .slice()
    .reverse()
    .filter(l => !d.usedLogs.includes(l.id))
    .slice(0, 5);
  if (quests.length === 0) {
    qDiv.innerHTML += '<div class="text-xs opacity-70">No recent quests.</div>';
  } else {
    quests.forEach(l => {
      const row = document.createElement("div");
      row.className = "flex items-center justify-between text-sm mb-1 gap-2";
      const label = document.createElement("span");
      label.textContent = `${l.title} (${l.xp} XP)`;
      row.appendChild(label);
      const attackBtn = createHoldButtonElement("Attack", "attack");
      attackBtn.style.width = "auto";
      attackBtn.style.minWidth = "6.5rem";
      attackBtn.style.flexShrink = "0";
      attachHoldButton(attackBtn, {
        variant: "attack",
        onComplete: () => attackDungeon(l.id),
        getDrops: result => createAttackDrops(result)
      });
      row.appendChild(attackBtn);
      qDiv.appendChild(row);
    });
  }
  const sBtn = document.createElement("button");
  sBtn.id = "btn-surrender";
  sBtn.className = "px-4 py-2 rounded bg-rose-700 hover:bg-rose-600";
  sBtn.textContent = "Surrender";
  sBtn.onclick = () => {
    addDungeonChatBlock("Retreat", ["You surrendered."]);
    d.current = null;
    d.currentRun = 0;
    save();
    renderDungeon();
  };
  actDiv.appendChild(sBtn);
}
function renderDevMonsters() {
  const container = el("dev-monsters");
  container.innerHTML = "";
  MONSTERS.forEach(m => {
    const wrapper = document.createElement("div");
    wrapper.innerHTML = `<label class=\"block text-sm\">${m.name}</label><input type=\"file\" data-monster=\"${m.name}\" accept=\"image/png\" class=\"w-full text-sm\"/>`;
    const input = wrapper.querySelector("input");
    input.onchange = e => {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = () => {
        state.settings.monsterImages[m.name] = reader.result;
        save();
        renderDungeon();
      };
      reader.readAsDataURL(file);
    };
    container.appendChild(wrapper);
  });
}
function renderDevItemAudio() {
  const container = el("dev-item-audio");
  if (!container) return;
  container.innerHTML = "";
  Object.keys(state.settings.itemAudio).forEach(name => {
    const entry = state.settings.itemAudio[name];
    const wrap = document.createElement("div");
    const label = document.createElement("label");
    label.className = "block text-sm";
    label.textContent = name;
    const select = document.createElement("select");
    select.className = "w-full px-2 py-1 rounded bg-slate-800 text-sm mb-1";
    select.innerHTML = '<option value="consume">Consume</option><option value="drink">Drink</option><option value="custom">Custom</option>';
    select.value = entry.type || "consume";
    const file = document.createElement("input");
    file.type = "file";
    file.accept = "audio/*";
    file.className = "w-full text-sm";
    select.onchange = () => {
      entry.type = select.value;
      if (select.value !== "custom") delete entry.src;
      save();
    };
    file.onchange = e => {
      const f = e.target.files[0];
      if (!f) return;
      const reader = new FileReader();
      reader.onload = () => {
        entry.type = "custom";
        entry.src = reader.result;
        save();
      };
      reader.readAsDataURL(f);
    };
    wrap.appendChild(label);
    wrap.appendChild(select);
    wrap.appendChild(file);
    container.appendChild(wrap);
  });
  const addBtn = el("dev-add-item-audio");
  if (addBtn) {
    addBtn.onclick = () => {
      textModal("Item name", "", name => {
        if (!name) return;
        state.settings.itemAudio[name] = { type: "consume" };
        save();
        renderDevItemAudio();
      });
    };
  }
}
const TITLE_TIERS = [
  { level: 400, title: "Mortal Savant" },
  { level: 350, title: "FalconKnight" },
  { level: 300, title: "SpellSword" },
  { level: 250, title: "SwordMaster" },
  { level: 200, title: "Paladin" },
  { level: 150, title: "Hero" },
  { level: 125, title: "Mercenary" },
  { level: 100, title: "Soilder" },
  { level: 50, title: "Fighter" },
  { level: 25, title: "Adventurer" },
  { level: 1, title: "Commoner" }
];
function getTitle(level) {
  return TITLE_TIERS.find(t => level >= t.level)?.title || "Commoner";
}
const STREAK_TIERS = [
  { days: 365, title: "1-year", icon: "1year.png" },
  { days: 180, title: "6-month", icon: "6month.png" },
  { days: 120, title: "4-month", icon: "4month.png" },
  { days: 60, title: "2-month", icon: "2month.png" },
  { days: 30, title: "1-month", icon: "1month.png" },
  { days: 7, title: "7-day", icon: "7day.png" },
  { days: 3, title: "3-day", icon: "3day.png" }
];
function getStreakTier(days) {
  return STREAK_TIERS.find(t => days >= t.days) || null;
}
const MONSTERS = [
  { name: "Clair Obscur", tier: 4, weak: ["Reading", "Strategy"], resist: ["Mindfulness"], ability: "heal5", rewardXp: 15000, rewardGold: 2000, limit: 15 },
  { name: "Red Eyes Black Dragon", tier: 4, weak: ["Strength", "Fitness"], resist: ["Vitality"], rewardXp: 12000, rewardGold: 1000, limit: 15 },
  { name: "Golem", tier: 3, weak: ["Dexterity"], resist: ["Constitution"], rewardXp: 7000, rewardGold: 250 },
  { name: "Grand Mimic", tier: 3, weak: ["Reading"], resist: ["Strength", "Constitution"], rewardXp: 7500, rewardGold: 3000 },
  { name: "Mythic Succubus", tier: 3, weak: ["Cooking", "Charisma"], resist: ["Mindfulness", "Vitality"], rewardXp: 7250, rewardGold: 300 },
  { name: "Necromancer", tier: 3, weak: ["Productivity"], resist: ["Reading", "Charisma"], rewardXp: 7250, rewardGold: 300 },
  { name: "Catacomb Giant Spider", tier: 3, weak: ["Strategy"], resist: ["Dexterity", "Vitality"], rewardXp: 7000, rewardGold: 275 },
  { name: "Cyclops", tier: 2, weak: ["Strength"], resist: ["Strategy"], rewardXp: 3500, rewardGold: 150 },
  { name: "Mimic", tier: 2, weak: ["Strategy", "Reading"], resist: ["Mindfulness"], rewardXp: 3750, rewardGold: 175 },
  { name: "Undead Royal Knight", tier: 2, weak: ["Constitution", "Strategy"], resist: ["Dexterity"], rewardXp: 3600, rewardGold: 150 },
  { name: "Seer", tier: 2, weak: ["Study"], resist: ["Mindfulness", "Charisma"], rewardXp: 3400, rewardGold: 125 },
  { name: "Toxic Evil Spirit", tier: 2, weak: ["Mindfulness"], resist: ["Vitality", "Productivity"], rewardXp: 3200, rewardGold: 100 },
  { name: "Zombie Horde", tier: 2, weak: ["Constitution"], resist: ["Dexterity", "Study"], rewardXp: 3300, rewardGold: 125 },
  { name: "Giant Spider", tier: 2, weak: ["Strategy"], resist: ["Vitality", "Mindfulness"], rewardXp: 3600, rewardGold: 150 },
  { name: "Evil Spirit", tier: 1, weak: ["Study"], resist: ["Mindfulness", "Productivity"], rewardXp: 1000, rewardGold: 75 },
  { name: "Powerful Evil Spirit", tier: 1, weak: ["Study"], resist: ["Mindfulness"], rewardXp: 2000, rewardGold: 90 },
  { name: "Goblin Gang", tier: 1, weak: ["Dexterity", "Cooking"], resist: ["Charisma"], rewardXp: 2100, rewardGold: 100 }
];
function monsterBaseHP(tier) {
  if (tier === 1) return 250;
  if (tier === 2) return 575;
  if (tier === 3) return 1300;
  return 3750;
}
function rand(min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min;
}
function goldForDiff(diff) {
  if (diff <= 100) return rand(1, 5);
  if (diff <= 250) return rand(5, 30);
  if (diff <= 1000) return rand(25, 60);
  if (diff <= 1500) return rand(70, 100);
  return rand(100, 300);
}
function sanitizeDailyResetTime(value) {
  if (typeof value !== "string") return "04:00";
  const match = value.match(/^(\d{1,2}):(\d{1,2})$/);
  if (!match) return "04:00";
  const hour = Math.min(23, Math.max(0, parseInt(match[1], 10)));
  const minute = Math.min(59, Math.max(0, parseInt(match[2], 10)));
  return `${pad(hour)}:${pad(minute)}`;
}
function getDailyResetParts() {
  const sanitized = sanitizeDailyResetTime(state.settings.dailyResetTime || "04:00");
  if (sanitized !== state.settings.dailyResetTime) {
    state.settings.dailyResetTime = sanitized;
    save();
  }
  const [hour, minute] = sanitized.split(":").map(v => parseInt(v, 10));
  return { hour, minute, raw: sanitized };
}
function parseDateOnly(value) {
  if (!value || typeof value !== "string") return null;
  const parts = value.split("-");
  if (parts.length !== 3) return null;
  const [year, month, day] = parts.map(Number);
  if ([year, month, day].some(n => Number.isNaN(n))) return null;
  const date = new Date();
  date.setFullYear(year, month - 1, day);
  date.setHours(0, 0, 0, 0);
  return date;
}
function formatDateKey(date) {
  return `${date.getFullYear()}-${pad(date.getMonth() + 1)}-${pad(date.getDate())}`;
}
function getQuestDayDate(reference = new Date()) {
  const { hour, minute } = getDailyResetParts();
  const questDay = new Date(reference);
  questDay.setHours(0, 0, 0, 0);
  const boundary = new Date(questDay);
  boundary.setHours(hour, minute, 0, 0);
  if (reference < boundary) {
    questDay.setDate(questDay.getDate() - 1);
  }
  return questDay;
}
function getDayBoundaryStart(reference = Date.now()) {
  const refDate = new Date(reference);
  const questDay = getQuestDayDate(refDate);
  const { hour, minute } = getDailyResetParts();
  questDay.setHours(hour, minute, 0, 0);
  return questDay.getTime();
}
function formatQuestDue(due) {
  const date = parseDateOnly(due);
  if (!date) return "";
  const now = new Date();
  const options = { month: "short", day: "numeric", weekday: "short" };
  if (date.getFullYear() !== now.getFullYear()) options.year = "numeric";
  return date.toLocaleDateString(undefined, options);
}
function advanceDueDate(due, frequency) {
  const date = parseDateOnly(due);
  if (!date) return due;
  const originalDay = date.getDate();
  switch (frequency) {
    case "bi-daily":
      date.setDate(date.getDate() + 2);
      break;
    case "weekly":
      date.setDate(date.getDate() + 7);
      break;
    case "bi-weekly":
      date.setDate(date.getDate() + 14);
      break;
    case "monthly":
      date.setDate(1);
      date.setMonth(date.getMonth() + 1);
      {
        const daysInMonth = new Date(date.getFullYear(), date.getMonth() + 1, 0).getDate();
        date.setDate(Math.min(originalDay, daysInMonth));
      }
      break;
    default:
      date.setDate(date.getDate() + 1);
      break;
  }
  return `${date.getFullYear()}-${pad(date.getMonth() + 1)}-${pad(date.getDate())}`;
}
function getDailyTagIds() {
  return state.tags
    .filter(tag => tag && typeof tag.name === "string" && tag.id)
    .filter(tag => tag.name.toLowerCase() === "daily")
    .map(tag => tag.id);
}
function questHasDailyTag(quest, dailyTagIds) {
  if (!quest || !Array.isArray(quest.tags)) return false;
  return quest.tags.some(id => dailyTagIds.includes(id));
}
function save() {
  localStorage.setItem("taskforge_save", JSON.stringify(state));
}
function show(view) {
  [
    "view-quests",
    "view-stats",
    "view-status",
    "view-skills",
    "view-tags",
    "view-shop",
    "view-inventory",
    "view-inbox",
    "view-notes",
    "view-log",
    "view-settings",
    "view-dungeon"
  ].forEach(id => el(id).classList.toggle("hidden", id !== view));
}
  function nextLevelXP() {
    const lvl = ((state.player.level - 1) % 100) + 1;
    return lvl * 50;
  }
  function addXP(amount) {
    state.player.xp += amount;
    while (state.player.xp >= nextLevelXP()) {
      state.player.xp -= nextLevelXP();
      state.player.level++;
      if (state.player.level % 100 === 1) {
        state.player.prestige = (state.player.prestige || 0) + 1;
        state.player.xp = 0;
        break;
      }
    }
    while (state.player.xp < 0 && state.player.level > 1) {
      state.player.level--;
      if (state.player.level % 100 === 0 && state.player.prestige) state.player.prestige--;
      state.player.xp += nextLevelXP();
    }
    if (state.player.xp < 0) state.player.xp = 0;
  }
function completeQuest(id) {
  const idx = state.quests.findIndex(q => q.id === id);
  if (idx === -1) return;
  const q = state.quests[idx];
  const previousDue = q.due || "";
  const previousLastCompletedAt = q.lastCompletedAt || null;
  const previousReminderTracker = q.reminderTracker ? { ...q.reminderTracker } : {};
  const repeatFrequency = q.repeatFrequency || null;
  const gold = goldForDiff(q.diff);
  const stBase = Math.floor(Math.abs(q.xp) / 300);
  const spBase = Math.abs(q.xp) / 30;
  if (currentLvlSound) {
    currentLvlSound.pause();
    currentLvlSound.currentTime = 0;
    currentLvlSound = null;
  }
  const levelBefore = state.player.level;
  addXP(q.xp);
  const statEntries = [];
  if (q.stats && q.stats.length) {
    q.stats.forEach(st => {
      const pts = q.xp < 0 ? -Math.floor(stBase * st.mult) : Math.floor(stBase * st.mult);
      state.player.mainstats[st.name] = Math.max(
        0,
        (state.player.mainstats[st.name] || 0) + pts
      );
      statEntries.push({ name: st.name, points: pts });
    });
  }
  const skillEntries = [];
  if (q.skills && q.skills.length) {
    q.skills.forEach(sk => {
      const pts = q.xp < 0 ? -Math.floor(spBase * sk.mult) : Math.floor(spBase * sk.mult);
      state.player.skills[sk.name] = Math.max(
        0,
        (state.player.skills[sk.name] || 0) + pts
      );
      if (state.player.skills[sk.name] === 0) delete state.player.skills[sk.name];
      skillEntries.push({ name: sk.name, points: pts });
    });
  }
  state.player.gold += gold;
  const completedAt = Date.now();
  q.lastCompletedAt = completedAt;
  if (q.repeat) {
    if (previousDue) {
      q.due = advanceDueDate(previousDue, repeatFrequency || "daily");
    }
    q.reminderTracker = {};
  }
  const logEntry = {
    id: crypto.randomUUID(),
    questId: q.id,
    title: q.title,
    xp: q.xp,
    diff: q.diff,
    time: q.time,
    stats: statEntries,
    skills: skillEntries,
    tags: q.tags ? q.tags.slice() : [],
    notes: q.notes,
    repeat: q.repeat,
    anti: q.anti,
    due: previousDue,
    gold,
    completedAt,
    noteColor: q.noteColor || "#0ea5e9",
    repeatFrequency,
    previousDue,
    previousLastCompletedAt,
    previousReminderTracker,
    lastCompletedAt: completedAt
  };
  state.log.push(logEntry);
  if (state.log.length > 200) state.log.shift();
  if (!q.repeat) state.quests.splice(idx, 1);
  if (!state.streak.last || completedAt - state.streak.last > 30 * 60 * 60 * 1000) {
    state.streak.count = 1;
  } else if (new Date(completedAt).toDateString() !== new Date(state.streak.last).toDateString()) {
    state.streak.count++;
  }
  state.streak.last = completedAt;
  const levelAfter = state.player.level;
  const questResult = {
    questId: q.id,
    title: q.title,
    xp: q.xp,
    gold,
    stats: statEntries,
    skills: skillEntries,
    logEntry,
    completedAt,
    levelBefore,
    levelAfter,
    levelUp: levelAfter > levelBefore
  };
  const statLines = statEntries
    .filter(entry => typeof entry.points === "number" && entry.points !== 0)
    .map(entry => `${entry.name} ${formatSigned(entry.points)}`);
  const skillLines = skillEntries
    .filter(entry => typeof entry.points === "number" && entry.points !== 0)
    .map(entry => `${entry.name} ${formatSigned(entry.points)}`);
  const codexLines = [
    `${formatSigned(q.xp)} XP`,
    `${formatSigned(gold)} Gold`,
    ...statLines,
    ...skillLines
  ];
  if (statLines.length === 0 && skillLines.length === 0) {
    codexLines.push("No stat or skill changes");
  }
  addDungeonChatBlock(`${q.title} Completed`, codexLines, {
    monsterKey: CODEX_KEY,
    createdAt: completedAt
  });
  save();
  render();
  if (questResult.levelUp) {
    currentLvlSound = levelSounds[state.settings.levelSound || 0];
    currentLvlSound.play();
  } else {
    goldSound.play();
  }
  return questResult;
}
function deleteQuest(id) {
  const idx = state.quests.findIndex(q => q.id === id);
  if (idx === -1) return;
  state.quests.splice(idx, 1);
  save();
  render();
}
function pad(n) {
  return String(n).padStart(2, "0");
}
function updateStreakTimer() {
  if (!state.streak.last || state.streak.count === 0) {
    el("streak-timer").textContent = "";
    return;
  }
  const diff = state.streak.last + 30 * 60 * 60 * 1000 - Date.now();
  if (diff <= 0) {
    state.streak.count = 0;
    state.streak.last = 0;
    save();
    render();
    el("streak-timer").textContent = "";
  } else {
    const h = pad(Math.floor(diff / 3600000));
    const m = pad(Math.floor((diff % 3600000) / 60000));
    const s = pad(Math.floor((diff % 60000) / 1000));
    el("streak-timer").textContent = `${h}:${m}:${s}`;
  }
}
function editTag(id) {
  const t = state.tags.find(t => t.id === id);
  if (!t) return;
  tagModal(t, (name, color, priority) => {
    if (name) {
      t.name = name;
      t.color = color;
      t.priority = priority;
      save();
      render();
    }
  });
}
function deleteTag(id) {
  const idx = state.tags.findIndex(t => t.id === id);
  if (idx === -1) return;
  state.tags.splice(idx, 1);
  state.quests.forEach(q => {
    if (Array.isArray(q.tags)) q.tags = q.tags.filter(t => t !== id);
  });
  state.log.forEach(l => {
    if (Array.isArray(l.tags)) l.tags = l.tags.filter(t => t !== id);
  });
  state.notes.forEach(n => {
    if (Array.isArray(n.tags)) n.tags = n.tags.filter(t => t !== id);
  });
  state.settings.customFilterTags = state.settings.customFilterTags.filter(t => t !== id);
  if (questFilterSelection === id) questFilterSelection = QUEST_FILTER_ALL;
  if (noteFilterSelection === id) noteFilterSelection = QUEST_FILTER_ALL;
  save();
  render();
}

function populateSkillOptions(sel, selectedValue) {
  const previous = selectedValue !== undefined ? selectedValue : sel.value;
  sel.innerHTML =
    '<option value="">None</option>' +
    state.skills.map(s => `<option value="${s.name}">${s.name}</option>`).join("");
  if (previous && Array.from(sel.options).some(opt => opt.value === previous)) {
    sel.value = previous;
  } else {
    sel.value = "";
  }
}

function addSkillRow(name = "", mult = 1) {
  const row = document.createElement("div");
  row.className = "flex gap-2";
  const select = document.createElement("select");
  select.className = "flex-1 px-3 py-2 rounded bg-slate-800 q-skill";
  populateSkillOptions(select, name);
  const input = document.createElement("input");
  input.type = "number";
  input.step = "0.1";
  input.min = "0.1";
  input.max = "1";
  input.value = mult;
  input.className = "w-20 px-2 py-2 rounded bg-slate-800 q-skill-mult";
  if (!el("q-adjust") || !el("q-adjust").checked) input.classList.add("hidden");
  row.appendChild(select);
  row.appendChild(input);
  el("q-skills").appendChild(row);
}
function populateStatOptions(sel, selectedValue) {
  const previous = selectedValue !== undefined ? selectedValue : sel.value;
  sel.innerHTML =
    '<option value="">None</option>' +
    Object.keys(state.player.mainstats)
      .map(s => `<option value="${s}">${s}</option>`)
      .join("");
  if (previous && Array.from(sel.options).some(opt => opt.value === previous)) {
    sel.value = previous;
  } else {
    sel.value = "";
  }
}

function addStatRow(name = "", mult = 1) {
  const row = document.createElement("div");
  row.className = "flex gap-2";
  const select = document.createElement("select");
  select.className = "flex-1 px-3 py-2 rounded bg-slate-800 q-stat";
  populateStatOptions(select, name);
  const input = document.createElement("input");
  input.type = "number";
  input.step = "0.1";
  input.min = "0.1";
  input.max = "1";
  input.value = mult;
  input.className = "w-20 px-2 py-2 rounded bg-slate-800 q-stat-mult";
  if (!el("q-stat-adjust") || !el("q-stat-adjust").checked) input.classList.add("hidden");
  row.appendChild(select);
  row.appendChild(input);
  el("q-stats").appendChild(row);
}

function editSkillMeta(name) {
  const sk = state.skills.find(s => s.name === name);
  if (!sk) return;
  skillModal(sk, ({ priority, desc }) => {
    sk.priority = priority;
    sk.desc = desc;
    save();
    render();
  }, true);
}

function deleteSkill(name) {
  delete state.player.skills[name];
  state.skills = state.skills.filter(s => s.name !== name);
  state.quests.forEach(q => {
    if (q.skills) q.skills = q.skills.filter(s => s.name !== name);
  });
  save();
  render();
}

function renderDevTitles() {
  const list = el("dev-titles");
  if (!list) return;
  list.innerHTML = "";
  TITLE_TIERS.forEach(t => {
    const custom = state.settings.titles[t.title];
    const name = custom?.name || t.title;
    const img = custom?.img || `Sprites/${t.title}.png`;
    const div = document.createElement("div");
    div.className = "flex items-center gap-2";
    div.innerHTML = `<img src="${img}" class="w-8 h-8 object-contain"/><span class="flex-1">${name}</span><button class="px-2 py-1 text-xs rounded bg-slate-700 dev-title-edit" data-key="${t.title}">Edit</button><button class="px-2 py-1 text-xs rounded bg-rose-700 dev-title-undo ${custom ? "" : "hidden"}" data-key="${t.title}">Undo</button>`;
    list.appendChild(div);
  });
  list.querySelectorAll(".dev-title-edit").forEach(btn => btn.onclick = () => editTitle(btn.dataset.key));
  list.querySelectorAll(".dev-title-undo").forEach(btn => btn.onclick = () => { delete state.settings.titles[btn.dataset.key]; save(); render(); });
}

function editTitle(key) {
  const custom = state.settings.titles[key] || { name: key, img: "" };
  const div = document.createElement("div");
  div.innerHTML = `<label class="block mb-2">Title Name</label>
    <input id="modal-title-name" class="w-full px-3 py-2 rounded bg-slate-800 mb-2" value="${custom.name}" />
    <label class="block mb-2">PNG</label>
    <input id="modal-title-file" type="file" accept="image/png" class="w-full mb-4" />
    <div class="text-right space-x-2">
      <button id="modal-cancel" class="px-3 py-1 rounded bg-slate-700">Cancel</button>
      <button id="modal-ok" class="px-3 py-1 rounded bg-emerald-700">Save</button>
    </div>`;
  showModal(div);
  el("modal-ok").onclick = () => {
    const name = el("modal-title-name").value.trim() || key;
    const file = el("modal-title-file").files[0];
    const finish = img => {
      state.settings.titles[key] = { name, img };
      save();
      render();
      closeModal();
    };
    if (file) {
      const reader = new FileReader();
      reader.onload = () => finish(reader.result);
      reader.readAsDataURL(file);
    } else {
      finish(custom.img);
    }
  };
  el("modal-cancel").onclick = closeModal;
}

function applyTheme() {
  const t = state.settings.theme || "default";
  document.body.classList.remove("theme-default", "theme-dark", "theme-emerald", "theme-rose", "theme-amber");
  document.body.classList.add(`theme-${t}`);
}
function undoQuest(logId) {
  const idx = state.log.findIndex(l => l.id === logId);
  if (idx === -1) return;
  const l = state.log[idx];
  addXP(-l.xp);
  state.player.gold = Math.max(0, state.player.gold - (l.gold || 0));
  if (l.stats && l.stats.length) {
    l.stats.forEach(s => {
      state.player.mainstats[s.name] = Math.max(
        0,
        (state.player.mainstats[s.name] || 0) - (s.points || 0)
      );
    });
  } else if (l.stat) {
    state.player.mainstats[l.stat] = Math.max(
      0,
      (state.player.mainstats[l.stat] || 0) - l.statPoints
    );
  }
  if (l.skills && l.skills.length) {
    l.skills.forEach(s => {
      state.player.skills[s.name] = Math.max(
        0,
        (state.player.skills[s.name] || 0) - (s.points || 0)
      );
      if (state.player.skills[s.name] === 0) delete state.player.skills[s.name];
    });
  } else if (l.skill) {
    state.player.skills[l.skill] = Math.max(
      0,
      (state.player.skills[l.skill] || 0) - l.skillPoints
    );
    if (state.player.skills[l.skill] === 0) delete state.player.skills[l.skill];
  }
  state.log.splice(idx, 1);
  if (!l.repeat) {
    state.quests.push({
      id: l.questId,
      title: l.title,
      diff: l.diff,
      time: l.time,
      xp: l.xp,
      stats: l.stats ? l.stats.map(s => ({ name: s.name, mult: 1 })) : (l.stat ? [{ name: l.stat, mult: 1 }] : []),
      skills: l.skills ? l.skills.map(s => ({ name: s.name, mult: 1 })) : (l.skill ? [{ name: l.skill, mult: 1 }] : []),
      tags: l.tags ? l.tags.slice() : [],
      notes: l.notes,
      repeat: l.repeat,
      repeatFrequency: l.repeatFrequency || null,
      anti: l.anti,
      due: l.previousDue !== undefined ? l.previousDue : (l.due || ""),
      noteColor: l.noteColor || "#0ea5e9",
      lastCompletedAt: l.previousLastCompletedAt || null,
      reminderTracker: l.previousReminderTracker ? { ...l.previousReminderTracker } : {}
    });
  } else {
    const quest = state.quests.find(q => q.id === l.questId);
    if (quest) {
      quest.due = l.previousDue !== undefined ? l.previousDue : quest.due;
      quest.lastCompletedAt = l.previousLastCompletedAt || null;
      quest.repeatFrequency = l.repeatFrequency || quest.repeatFrequency || "daily";
      quest.reminderTracker = l.previousReminderTracker ? { ...l.previousReminderTracker } : {};
    } else {
      state.quests.push({
        id: l.questId,
        title: l.title,
        diff: l.diff,
        time: l.time,
        xp: l.xp,
        stats: l.stats ? l.stats.map(s => ({ name: s.name, mult: 1 })) : (l.stat ? [{ name: l.stat, mult: 1 }] : []),
        skills: l.skills ? l.skills.map(s => ({ name: s.name, mult: 1 })) : (l.skill ? [{ name: l.skill, mult: 1 }] : []),
        tags: l.tags ? l.tags.slice() : [],
        notes: l.notes,
        repeat: true,
        repeatFrequency: l.repeatFrequency || "daily",
        anti: l.anti,
        due: l.previousDue !== undefined ? l.previousDue : (l.due || ""),
        noteColor: l.noteColor || "#0ea5e9",
        lastCompletedAt: l.previousLastCompletedAt || null,
        reminderTracker: l.previousReminderTracker ? { ...l.previousReminderTracker } : {}
      });
    }
  }
  save();
  render();
}
function startEdit(id) {
  const q = state.quests.find(q => q.id === id);
  if (!q) return;
  editingId = id;
  editingClearCompletion = false;
  antiQuest = q.anti || false;
  el("quest-form").classList.remove("hidden");
  el("q-title").value = q.title;
  el("q-diff").value = q.diff || 1000;
  el("q-time").value = q.time || 1;
  el("q-skills").innerHTML = "";
  (q.skills || []).forEach(s => addSkillRow(s.name, s.mult));
  if (!q.skills || q.skills.length === 0) addSkillRow();
  el("q-adjust").checked = (q.skills || []).some(s => s.mult !== 1);
  document.querySelectorAll(".q-skill-mult").forEach(i => i.classList.toggle("hidden", !el("q-adjust").checked));
  document.querySelectorAll(".q-skill").forEach(sel => populateSkillOptions(sel));
  el("q-stats").innerHTML = "";
  (q.stats || []).forEach(s => addStatRow(s.name, s.mult));
  if (!q.stats || q.stats.length === 0) addStatRow();
  el("q-stat-adjust").checked = (q.stats || []).some(s => s.mult !== 1);
  document.querySelectorAll(".q-stat-mult").forEach(i => i.classList.toggle("hidden", !el("q-stat-adjust").checked));
  document.querySelectorAll(".q-stat").forEach(sel => populateStatOptions(sel));
  renderTagSelection(el("q-tag-options"), q.tags || [], "q-tag-option");
  el("q-due").value = q.due || "";
  el("q-repeat").checked = q.repeat || false;
  el("q-repeat-frequency").value = q.repeatFrequency || "daily";
  el("q-repeat-frequency").classList.toggle("hidden", !q.repeat);
  el("q-notes").value = q.notes || "";
  el("q-note-color").value = q.noteColor || "#0ea5e9";
  el("q-anti").classList.toggle("font-bold", antiQuest);
  const shouldOfferUngrey = Boolean(q.lastCompletedAt && q.lastCompletedAt >= getDayBoundaryStart());
  setUngreyButtonState({ visible: shouldOfferUngrey, active: false });
  el("btn-submit-quest").textContent = "Save";
}
  function render() {
    el("player-name-display").textContent = state.player.name;
    el("level").textContent = formatNumber(state.player.level);
    el("xp").textContent = formatNumber(state.player.xp);
    el("prestige").textContent = formatNumber(state.player.prestige);
    el("gold").textContent = formatNumber(state.player.gold);
    const baseTitle = getTitle(state.player.level);
    const custom = state.settings.titles[baseTitle];
    const displayTitle = custom?.name || baseTitle;
    const titleImg = custom?.img || `Sprites/${baseTitle}.png`;
    el("player-title").textContent = displayTitle;
    el("player-img").src = titleImg;
    const titleId = `title-${baseTitle}`;
    const levelReq = TITLE_TIERS.find(t => t.title === baseTitle)?.level || state.player.level;
    const existingTrophy = state.inventory.find(i => i.id === titleId);
    let changed = false;
    if (!existingTrophy) {
      state.inventory.push({
        id: titleId,
        title: `${displayTitle} Trophy`,
        desc: `Trophy for reaching level ${levelReq}`,
        img: titleImg,
        consumable: false
      });
      changed = true;
    } else {
      if (existingTrophy.title !== `${displayTitle} Trophy` || existingTrophy.desc !== `Trophy for reaching level ${levelReq}` || existingTrophy.img !== titleImg) {
        existingTrophy.title = `${displayTitle} Trophy`;
        existingTrophy.desc = `Trophy for reaching level ${levelReq}`;
        existingTrophy.img = titleImg;
        changed = true;
      }
    }
    if (changed) save();
    const xpToNext = nextLevelXP();
    const currentXp = Math.max(0, Math.round(state.player.xp));
    el("next-xp").textContent = formatNumber(xpToNext);
    const xpCurrentEl = el("xp-current");
    if (xpCurrentEl) xpCurrentEl.textContent = formatNumber(currentXp);
    const xpRemainingEl = el("xp-remaining");
    if (xpRemainingEl) xpRemainingEl.textContent = formatNumber(Math.max(0, xpToNext - currentXp));
    const xpProgressEl = el("xp-progress");
    if (xpProgressEl) {
      const percent = xpToNext ? Math.min(100, Math.max(0, (currentXp / xpToNext) * 100)) : 100;
      xpProgressEl.style.width = `${percent}%`;
    }
    const tier = getStreakTier(state.streak.count);
    if (tier && state.streak.count) {
      el("streak-display").innerHTML = `<img src="Sprites/${tier.icon}" class="inline w-5 h-5 mr-1"/>${tier.title} Streak (${state.streak.count})`;
      const streakId = `streak-${tier.title}`;
      if (!state.inventory.some(i => i.id === streakId)) {
        state.inventory.push({
          id: streakId,
          title: `${tier.title} Streak Trophy`,
          desc: `Trophy for achieving a ${tier.title} streak`,
          img: `Sprites/${tier.icon}`,
          consumable: false
        });
        save();
      }
    } else {
      el("streak-display").textContent = `Streak (${state.streak.count})`;
    }
    el("level-sound").value = state.settings.levelSound;
    el("audio-volume").value = state.settings.volume;
    el("audio-section").classList.toggle("hidden", state.settings.audioCollapsed);
    el("audio-toggle-symbol").textContent = state.settings.audioCollapsed ? "+" : "-";
    const reset = getDailyResetParts();
    el("daily-reset-time").value = reset.raw;
    updateNotificationUI();
    el("dev-theme").value = state.settings.theme || "default";
    applyTheme();
    renderDevTitles();
    renderDevMonsters();
    renderDevItemAudio();
    renderDungeon();
    updateDailyMail();
    renderInbox();
    updateInboxBadge();
    renderCustomFilterSettings();
    renderStatusPage();
    renderQuestFilters();
    renderNoteFilters();
    renderQuestList();
    renderNotes();
    if (!editingId) {
      el("q-stats").innerHTML = "";
      addStatRow();
      el("q-stat-adjust").checked = false;
      el("q-skills").innerHTML = "";
      addSkillRow();
      el("q-adjust").checked = false;
      renderTagSelection(el("q-tag-options"), [], "q-tag-option");
      el("q-note-color").value = "#0ea5e9";
      el("q-repeat").checked = false;
      el("q-repeat-frequency").value = "daily";
      el("q-repeat-frequency").classList.add("hidden");
    }
    document.querySelectorAll(".q-skill").forEach(sel => populateSkillOptions(sel));
    document.querySelectorAll(".q-stat").forEach(sel => populateStatOptions(sel));
    if (!editingNoteId) {
      renderTagSelection(el("note-tag-options"), [], "note-tag-option");
      el("note-color").value = "#0ea5e9";
      el("btn-save-note").textContent = "Save Entry";
    }
  const statsList = el("stats-list");
  statsList.innerHTML =
    '<canvas id="stats-chart"></canvas><table id="stats-table" class="mt-4 w-full text-sm"></table>';
  const ctx = el("stats-chart");
  if (statsChart) statsChart.destroy();
  statsChart = new Chart(ctx, {
    type: "radar",
    data: {
      labels: Object.keys(state.player.mainstats),
      datasets: [
        {
          data: Object.values(state.player.mainstats),
          backgroundColor: "rgba(14,165,233,0.2)",
          borderColor: "#0ea5e9"
        }
      ]
    },
    options: {
      scales: {
        r: {
          beginAtZero: true,
          ticks: { display: false },
          grid: { color: 'rgba(255,255,255,0.1)' },
          angleLines: { color: 'rgba(255,255,255,0.1)' },
          pointLabels: { color: '#cbd5e1' }
        }
      },
      plugins: { legend: { display: false } }
    }
  });
  const statsTable = el("stats-table");
  statsTable.innerHTML = Object.entries(state.player.mainstats)
    .map(([n, v]) => `<tr><td class="py-1">${n}</td><td class="py-1 text-right">${v}</td></tr>`)
    .join("");
  const skillsList = el("skills-list");
  skillsList.innerHTML = "";
  if (state.skills.length === 0) {
    skillsList.innerHTML = '<div class="text-sm opacity-70">No skills yet.</div>';
  } else {
    state.skills
      .slice()
      .sort((a, b) => (a.priority || 0) - (b.priority || 0))
      .forEach(sk => {
        const val = state.player.skills[sk.name] || 0;
        const div = document.createElement("div");
        div.className = "mb-2 text-sm";
        div.innerHTML = `<div class=\"flex items-center gap-2\"><span class=\"flex-1 cursor-pointer skill-name\" data-name=\"${sk.name}\">${sk.name} (p${sk.priority})</span><span>${val}</span><span class=\"cursor-pointer text-sky-400\" data-act=\"edit\">edit</span><span class=\"cursor-pointer text-rose-400\" data-act=\"del\">delete</span></div><p class=\"sk-desc hidden text-xs mt-1 opacity-80\">${sk.desc}</p>`;
        div.querySelector('.skill-name').onclick = () => div.querySelector('.sk-desc').classList.toggle('hidden');
        div.querySelector('[data-act="edit"]').onclick = () => editSkillMeta(sk.name);
        div.querySelector('[data-act="del"]').onclick = () => deleteSkill(sk.name);
        skillsList.appendChild(div);
      });
  }
  const tagsList = el("tags-list");
  tagsList.innerHTML = "";
  if (state.tags.length === 0) {
    tagsList.innerHTML = '<div class="text-sm opacity-70">No tags yet.</div>';
  } else {
    state.tags
      .slice()
      .sort((a, b) => (a.priority || 0) - (b.priority || 0))
      .forEach(t => {
        const div = document.createElement("div");
        div.className = "flex items-center gap-2 mb-1 text-sm";
        div.innerHTML = `<span class=\"w-4 h-4 rounded\" style=\"background:${t.color}\"></span><span class=\"flex-1\">${t.name} (p${t.priority || 0})</span><span class=\"cursor-pointer text-sky-400\" data-act=\"edit\">edit</span><span class=\"cursor-pointer text-rose-400\" data-act=\"del\">delete</span>`;
        div.querySelector('[data-act="edit"]').onclick = () => editTag(t.id);
        div.querySelector('[data-act="del"]').onclick = () => deleteTag(t.id);
        tagsList.appendChild(div);
      });
  }
  const shopList = el("shop-list");
  shopList.innerHTML = "";
  if (state.shop.length === 0) {
    shopList.innerHTML = '<div class="text-sm opacity-70">No items in shop.</div>';
  } else {
    state.shop.forEach(item => {
      const div = document.createElement("div");
      div.className = "flex items-center gap-3 p-3 rounded bg-slate-800";
      div.innerHTML = `<img src="${item.img}" class=\"w-12 h-12 object-contain\"/><div class=\"flex-1\"><div class=\"font-semibold\">${item.title}</div><div class=\"text-xs opacity-70\">${item.cost}g</div></div><button class=\"buy px-2 py-1 text-xs rounded bg-emerald-700 hover:bg-emerald-600\">Buy</button><span class=\"edit text-xs text-sky-400 cursor-pointer ml-2\">edit</span>`;
      div.querySelector(".buy").onclick = () => {
        confirmModal(`Buy <strong>${item.title}</strong> for ${item.cost} gold?`, () => {
          if (state.player.gold >= item.cost) {
            state.player.gold -= item.cost;
            state.inventory.push({ id: crypto.randomUUID(), title: item.title, desc: item.desc, img: item.img, consumable: true });
            if (!item.rebuy) state.shop = state.shop.filter(s => s.id !== item.id);
            save();
            render();
            goldSound.play();
          } else {
            infoModal("Not enough gold");
          }
        });
      };
      div.querySelector(".edit").onclick = () => {
        editingShopId = item.id;
        el("shop-title").value = item.title;
        el("shop-desc").value = item.desc;
        el("shop-cost").value = item.cost;
        el("shop-rebuy").checked = item.rebuy;
        el("shop-form").classList.remove("hidden");
      };
      shopList.appendChild(div);
    });
  }
  const invList = el("inventory-list");
  invList.innerHTML = "";
  if (state.inventory.length === 0) {
    invList.innerHTML = '<div class="text-sm opacity-70">Inventory empty.</div>';
  } else {
    state.inventory.forEach((item, idx) => {
      const div = document.createElement("div");
      div.className = "p-2 border rounded text-center";
      const img = document.createElement("img");
      img.src = item.img;
      img.className = "w-full h-16 object-contain mx-auto cursor-pointer";
      img.onclick = () => itemModal(item, idx);
      div.appendChild(img);
      const title = document.createElement("div");
      title.className = "text-xs mt-1";
      title.textContent = item.title;
      div.appendChild(title);
      if (item.consumable) {
        const btn = document.createElement("button");
        btn.className = "mt-1 px-2 py-1 text-xs rounded bg-emerald-700 hover:bg-emerald-600";
        btn.textContent = "Consume";
        btn.onclick = e => {
          e.stopPropagation();
          confirmModal(`Consume <strong>${item.title}</strong>?`, () => {
            state.inventory.splice(idx, 1);
            save();
            render();
            playItemSound(item);
          });
        };
        div.appendChild(btn);
      }
      invList.appendChild(div);
    });
  }
  const logList = el("log-list");
  logList.innerHTML = "";
  if (state.log.length === 0) {
    logList.innerHTML = '<div class="text-sm opacity-70">No completed quests yet.</div>';
  } else {
    state.log
      .slice()
      .reverse()
      .forEach(l => {
        const node = el("tpl-log").content.cloneNode(true);
        node.querySelector(".l-title").textContent = l.title;
        node.querySelector(".l-xp").textContent = l.xp >= 0 ? `+${l.xp}` : l.xp;
        node.querySelector(".l-stat").textContent = l.stats
          ? l.stats.map(s => `${s.name}${s.points ? ` ${s.points > 0 ? '+' : ''}${s.points}` : ''}`).join(", ")
          : "";
        node.querySelector(".l-skill").textContent = l.skills
          ? l.skills
              .map(s => `${s.name}${s.points ? `+${s.points}` : ''}`)
              .join(", ")
          : "";
        if (l.due) node.querySelector(".l-due").textContent = `Due: ${formatQuestDue(l.due)}`;
        node.querySelector(".l-time").textContent = new Date(l.completedAt).toLocaleString();
        node.querySelector(".l-notes").textContent = l.notes;
        node.querySelector(".l-undo").onclick = () => undoQuest(l.id);
        logList.appendChild(node);
      });
  }
  el("btn-submit-quest").textContent = editingId ? "Save" : "Add Quest";
  updateStreakTimer();
}
// Events
el("edit-name").onclick = () => {
  textModal("Player name", state.player.name, val => {
    if (val) {
      state.player.name = val;
      save();
      render();
    }
  });
};
el("btn-open-quests").onclick = () => { show("view-quests"); renderQuestFilters(); renderQuestList(); };
el("btn-open-stats").onclick = () => show("view-stats");
el("btn-open-status").onclick = () => { show("view-status"); renderStatusPage(); };
el("btn-open-skills").onclick = () => show("view-skills");
el("btn-open-tags").onclick = () => show("view-tags");
el("btn-open-shop").onclick = () => show("view-shop");
el("btn-open-inventory").onclick = () => show("view-inventory");
el("btn-open-notes").onclick = () => { show("view-notes"); renderNoteFilters(); renderNotes(); };
el("btn-open-log").onclick = () => show("view-log");
el("btn-open-settings").onclick = () => show("view-settings");
el("btn-open-dungeon").onclick = () => { show("view-dungeon"); renderDungeon(); };
el("btn-open-inbox").onclick = () => openInbox();
el("btn-show-form").onclick = () => {
  editingId = null;
  antiQuest = false;
  editingClearCompletion = false;
  el("q-anti").classList.remove("font-bold");
  el("quest-form").reset();
  el("q-skills").innerHTML = "";
  addSkillRow();
  el("q-adjust").checked = false;
  el("q-stats").innerHTML = "";
  addStatRow();
  el("q-stat-adjust").checked = false;
  document.querySelectorAll(".q-stat").forEach(sel => populateStatOptions(sel));
  document.querySelectorAll(".q-skill").forEach(sel => populateSkillOptions(sel));
  renderTagSelection(el("q-tag-options"), [], "q-tag-option");
  el("q-note-color").value = "#0ea5e9";
  el("q-repeat").checked = false;
  el("q-repeat-frequency").value = "daily";
  el("q-repeat-frequency").classList.add("hidden");
  setUngreyButtonState({ visible: false, active: false });
  el("btn-submit-quest").textContent = "Add Quest";
  el("quest-form").classList.toggle("hidden");
};
const ungreyBtn = el("btn-quest-ungrey");
if (ungreyBtn) {
  ungreyBtn.onclick = () => {
    if (ungreyBtn.classList.contains("hidden")) return;
    editingClearCompletion = !editingClearCompletion;
    setUngreyButtonState({ visible: true, active: editingClearCompletion });
  };
}
el("quest-form").onsubmit = e => {
  e.preventDefault();
  const diff = +el("q-diff").value;
  const time = +el("q-time").value;
  const baseXP = Math.round(diff * time);
  const xp = antiQuest ? Math.round(baseXP * -0.25) : baseXP;
  const stats = Array.from(document.querySelectorAll(".q-stat"))
    .map((sel, i) => {
      const name = sel.value;
      if (!name) return null;
      const mult = +document.querySelectorAll(".q-stat-mult")[i].value || 1;
      return { name, mult };
    })
    .filter(Boolean);
  const skills = Array.from(document.querySelectorAll(".q-skill"))
    .map((sel, i) => {
      const name = sel.value;
      if (!name) return null;
      const mult = +document.querySelectorAll(".q-skill-mult")[i].value || 1;
      return { name, mult };
    })
    .filter(Boolean);
  const repeat = el("q-repeat").checked;
  const repeatFrequency = repeat ? (el("q-repeat-frequency").value || "daily") : null;
  const dueValue = (el("q-due").value || "").trim();
  const questId = editingId || crypto.randomUUID();
  const existingQuest = state.quests.find(q => q.id === editingId);
  let lastCompletedAt = existingQuest ? existingQuest.lastCompletedAt || null : null;
  if (editingClearCompletion) {
    lastCompletedAt = null;
  }
  const q = {
    id: questId,
    title: el("q-title").value || "Untitled",
    diff,
    time,
    xp,
    stats,
    skills,
    tags: Array.from(el("q-tag-options").querySelectorAll(".q-tag-option:checked")).map(i => i.value),
    due: dueValue,
    repeat,
    repeatFrequency,
    anti: antiQuest,
    notes: el("q-notes").value,
    noteColor: el("q-note-color").value || "#0ea5e9",
    lastCompletedAt,
    reminderTracker: existingQuest && existingQuest.reminderTracker
      ? { ...existingQuest.reminderTracker }
      : {}
  };
  if (existingQuest && existingQuest.due !== q.due) {
    q.reminderTracker = {};
  }
  const existing = state.quests.findIndex(quest => quest.id === editingId);
  if (existing !== -1) state.quests[existing] = q; else state.quests.push(q);
  editingId = null;
  antiQuest = false;
  editingClearCompletion = false;
  save();
  render();
  el("quest-form").reset();
  el("quest-form").classList.add("hidden");
  setUngreyButtonState({ visible: false, active: false });
};
el("btn-show-note-form").onclick = () => {
  editingNoteId = null;
  el("note-form").reset();
  renderTagSelection(el("note-tag-options"), [], "note-tag-option");
  el("note-color").value = "#0ea5e9";
  el("note-form").classList.toggle("hidden");
  el("btn-save-note").textContent = "Save Entry";
};
el("btn-cancel-note").onclick = () => {
  editingNoteId = null;
  el("note-form").reset();
  el("note-form").classList.add("hidden");
  renderTagSelection(el("note-tag-options"), [], "note-tag-option");
  el("note-color").value = "#0ea5e9";
  el("btn-save-note").textContent = "Save Entry";
};
el("note-form").onsubmit = e => {
  e.preventDefault();
  const title = el("note-title").value.trim();
  const body = el("note-body").value.trim();
  const color = el("note-color").value || "#0ea5e9";
  const tags = Array.from(el("note-tag-options").querySelectorAll(".note-tag-option:checked")).map(i => i.value);
  const now = Date.now();
  if (editingNoteId) {
    const note = state.notes.find(n => n.id === editingNoteId);
    if (note) {
      note.title = title || "Untitled";
      note.body = body;
      note.color = color;
      note.tags = tags;
      note.updatedAt = now;
    }
  } else {
    state.notes.push({
      id: crypto.randomUUID(),
      title: title || "Untitled",
      body,
      color,
      tags,
      updatedAt: now
    });
  }
  editingNoteId = null;
  save();
  renderNotes();
  renderNoteFilters();
  el("note-form").reset();
  el("note-form").classList.add("hidden");
  renderTagSelection(el("note-tag-options"), [], "note-tag-option");
  el("note-color").value = "#0ea5e9";
  el("btn-save-note").textContent = "Save Entry";
};
el("btn-add-skill-row").onclick = () => addSkillRow();
el("q-adjust").onchange = () => {
  const show = el("q-adjust").checked;
  document.querySelectorAll(".q-skill-mult").forEach(i => i.classList.toggle("hidden", !show));
};
el("btn-add-stat-row").onclick = () => addStatRow();
el("q-stat-adjust").onchange = () => {
  const show = el("q-stat-adjust").checked;
  document.querySelectorAll(".q-stat-mult").forEach(i => i.classList.toggle("hidden", !show));
};
el("q-repeat").onchange = () => {
  const show = el("q-repeat").checked;
  const select = el("q-repeat-frequency");
  select.classList.toggle("hidden", !show);
  if (show && !select.value) select.value = "daily";
};
el("btn-toggle-notifications").onclick = () => {
  if (!("Notification" in window)) return;
  if (state.settings.notificationsEnabled) {
    state.settings.notificationsEnabled = false;
    save();
    updateNotificationUI();
    return;
  }
  if (Notification.permission === "granted") {
    state.settings.notificationsEnabled = true;
    save();
    updateNotificationUI();
  } else if (Notification.permission === "denied") {
    state.settings.notificationsEnabled = false;
    save();
    updateNotificationUI();
  } else {
    Notification.requestPermission().then(result => {
      state.settings.notificationsEnabled = result === "granted";
      save();
      updateNotificationUI();
    });
  }
};
el("daily-reset-time").onchange = e => {
  const value = sanitizeDailyResetTime(e.target.value || "04:00");
  state.settings.dailyResetTime = value;
  e.target.value = value;
  save();
  renderQuestList();
  updateDailyMail();
  checkQuestReminders();
};
el("dev-theme").onchange = e => {
  state.settings.theme = e.target.value;
  applyTheme();
  save();
};
el("dev-shop-img").onchange = e => {
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = () => {
    state.settings.defaultShopImg = reader.result;
    save();
  };
  reader.readAsDataURL(file);
};
el("btn-save-assets").onclick = () => {
  save();
  infoModal("Custom assets saved.");
};
el("btn-show-shop-form").onclick = () => {
  editingShopId = null;
  el("shop-form").reset();
  el("shop-form").classList.toggle("hidden");
};
el("shop-form").onsubmit = e => {
  e.preventDefault();
  const title = el("shop-title").value || "Untitled";
  const desc = el("shop-desc").value || "";
  const cost = +el("shop-cost").value || 0;
  const rebuy = el("shop-rebuy").checked;
  const file = el("shop-img").files[0];
  const id = editingShopId || crypto.randomUUID();
  const finish = imgData => {
    const item = { id, title, desc, cost, img: imgData || state.settings.defaultShopImg || "", rebuy };
    const idx = state.shop.findIndex(s => s.id === editingShopId);
    if (idx !== -1) state.shop[idx] = item; else state.shop.push(item);
    editingShopId = null;
    save();
    render();
    el("shop-form").reset();
    el("shop-form").classList.add("hidden");
  };
  if (file) {
    const reader = new FileReader();
    reader.onload = () => finish(reader.result);
    reader.readAsDataURL(file);
  } else {
    const existing = editingShopId ? state.shop.find(s => s.id === editingShopId)?.img || state.settings.defaultShopImg || "" : state.settings.defaultShopImg || "";
    finish(existing);
  }
};
el("btn-clear-done").onclick = () => {
  state.quests = [];
  save();
  render();
};
el("btn-export").onclick = () => {
  const data = JSON.stringify(state);
  const blob = new Blob([data], { type: "application/json" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = "taskforge_save.json";
  a.click();
  URL.revokeObjectURL(url);
};
el("file-import").onchange = e => {
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = () => {
    try {
      const data = JSON.parse(reader.result);
      localStorage.setItem("taskforge_save", JSON.stringify(data));
      location.reload();
    } catch (err) {
      infoModal("Invalid file");
    }
  };
  reader.readAsText(file);
};
el("btn-reset").onclick = () => {
  const div = document.createElement("div");
  div.innerHTML = `<div class=\"mb-2 text-sm\">Type <strong>Confirm</strong> to reset</div>
    <input id=\"modal-input\" class=\"w-full px-3 py-2 rounded bg-slate-800 mb-4\" />
    <div class=\"text-right space-x-2\">
      <button id=\"modal-cancel\" class=\"px-3 py-1 rounded bg-slate-700\">Cancel</button>
      <button id=\"modal-ok\" class=\"px-3 py-1 rounded bg-rose-700\">Reset</button>
    </div>`;
  showModal(div);
  el("modal-ok").onclick = () => {
    if (el("modal-input").value.trim().toLowerCase() === "confirm") {
      localStorage.removeItem("taskforge_save");
      location.reload();
    }
    closeModal();
  };
  el("modal-cancel").onclick = closeModal;
};
el("btn-add-skill").onclick = () => {
  skillModal({ name: "", priority: 1, desc: "" }, data => {
    if (data.name && !state.skills.some(s => s.name === data.name)) {
      state.skills.push(data);
      state.player.skills[data.name] = 0;
      save();
      render();
    }
  });
};
el("btn-add-tag").onclick = () => {
  const name = el("tag-name").value.trim();
  const color = el("tag-color").value;
  const priority = +el("tag-priority").value || 0;
  if (name) {
    state.tags.push({ id: crypto.randomUUID(), name, color, priority });
    el("tag-name").value = "";
    el("tag-priority").value = "";
    save();
    render();
  }
};
el("btn-audio-toggle").onclick = () => {
  state.settings.audioCollapsed = !state.settings.audioCollapsed;
  save();
  render();
};
el("level-sound").onchange = () => {
  state.settings.levelSound = +el("level-sound").value;
  save();
};
el("audio-volume").oninput = e => {
  const v = +e.target.value;
  state.settings.volume = v;
  goldSound.volume = v;
  levelSounds.forEach(s => (s.volume = v));
  attackSound.volume = v;
  consumeSound.volume = v;
  drinkSound.volume = v;
  save();
};
el("q-anti").onclick = () => {
  antiQuest = !antiQuest;
  el("q-anti").classList.toggle("font-bold", antiQuest);
};
checkQuestReminders();
updateDailyMail();
setInterval(checkQuestReminders, 60 * 1000);
setInterval(updateDailyMail, 60 * 1000);
setInterval(updateStreakTimer, 1000);
registerPullToRefresh();
render();
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('service-worker.js');
}
</script>
</body>
</html>
